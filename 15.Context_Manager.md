# Python Context Managers: The Complete Guide üêç‚ú®

*Mastering Resource Management with Professional Style and Visual ASCII Art*

---

## Table of Contents

- [Introduction](#introduction)
- [What Are Context Managers?](#what-are-context-managers)
- [The `with` Statement Magic](#the-with-statement-magic)
- [Built-in Context Managers](#built-in-context-managers)
- [Creating Custom Context Managers](#creating-custom-context-managers)
  - [Class-Based Approach](#class-based-approach)
  - [Generator-Based Approach](#generator-based-approach)
- [The contextlib Module](#the-contextlib-module)
- [Advanced Context Management](#advanced-context-management)
- [Asynchronous Context Managers](#asynchronous-context-managers)
- [Best Practices and Patterns](#best-practices-and-patterns)
- [Real-World Examples](#real-world-examples)
- [Common Pitfalls and Solutions](#common-pitfalls-and-solutions)
- [Performance Considerations](#performance-considerations)
- [Conclusion](#conclusion)

---

## Introduction

Welcome to the comprehensive world of **Python Context Managers**! üéØ

Context managers are one of Python's most elegant features for resource management. They provide a clean, reliable way to handle resources that need proper setup and cleanup, ensuring your code is both robust and maintainable.

```ascii
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ           Context Manager Flow               ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îÇ
‚îÇ  ‚îÇ __enter__‚îÇ ‚Üí  ‚îÇ   with   ‚îÇ ‚Üí  ‚îÇ__exit__ ‚îÇ  ‚îÇ
‚îÇ  ‚îÇ  Setup   ‚îÇ    ‚îÇ  block   ‚îÇ    ‚îÇCleanup  ‚îÇ  ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

---

## What Are Context Managers?

**Context Managers** are Python objects that define methods to be used with the `with` statement. They implement the **context management protocol** which consists of two special methods:

- `__enter__()`: Sets up the context and returns a resource
- `__exit__()`: Cleans up the context, even if an exception occurs

```ascii
‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
‚ïë               Context Manager                ‚ïë
‚ïë                                              ‚ïë
‚ïë  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚ïë
‚ïë  ‚îÇ class MyContextManager:                 ‚îÇ ‚ïë
‚ïë  ‚îÇ     def __enter__(self):                ‚îÇ ‚ïë
‚ïë  ‚îÇ         # Setup resource                ‚îÇ ‚ïë
‚ïë  ‚îÇ         return resource                 ‚îÇ ‚ïë
‚ïë  ‚îÇ                                         ‚îÇ ‚ïë
‚ïë  ‚îÇ     def __exit__(self, exc_type,        ‚îÇ ‚ïë
‚ïë  ‚îÇ                        exc_val,         ‚îÇ ‚ïë
‚ïë  ‚îÇ                        exc_tb):         ‚îÇ ‚ïë
‚ïë  ‚îÇ         # Cleanup resource              ‚îÇ ‚ïë
‚ïë  ‚îÇ         return False                    ‚îÇ ‚ïë
‚ïë  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚ïë
‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù
```

### Why Context Managers Matter

1. **Automatic Resource Management**: Ensures resources are properly released
2. **Exception Safety**: Cleanup happens even if exceptions occur
3. **Cleaner Code**: Eliminates repetitive try/finally blocks
4. **Pythonic**: Following Python's philosophy of readable, maintainable code

---

## The `with` Statement Magic

The `with` statement is the gateway to context managers. Here's how it works:

```python
with context_manager() as resource:
    # Use the resource
    do_something_with(resource)
# Resource is automatically cleaned up here
```

```ascii
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                 WITH Statement Flow                 ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ                                                     ‚îÇ
‚îÇ  1. with expression as target:                      ‚îÇ
‚îÇ     ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îÇ
‚îÇ     ‚îÇ __enter__() is called                       ‚îÇ ‚îÇ
‚îÇ     ‚îÇ Result assigned to 'target'                 ‚îÇ ‚îÇ
‚îÇ     ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îÇ
‚îÇ                                                     ‚îÇ
‚îÇ  2. with block execution:                           ‚îÇ
‚îÇ     ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îÇ
‚îÇ     ‚îÇ Your code runs here                         ‚îÇ ‚îÇ
‚îÇ     ‚îÇ Can raise exceptions                        ‚îÇ ‚îÇ
‚îÇ     ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îÇ
‚îÇ                                                     ‚îÇ
‚îÇ  3. Block exit (normal or exception):               ‚îÇ
‚îÇ     ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îÇ
‚îÇ     ‚îÇ __exit__() is ALWAYS called                 ‚îÇ ‚îÇ
‚îÇ     ‚îÇ Exception info passed if any                ‚îÇ ‚îÇ
‚îÇ     ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### Traditional vs Context Manager Approach

**Traditional Approach (Error-Prone):**
```python
# ‚ùå Error-prone way
file = open('data.txt', 'w')
try:
    file.write('Hello, World!')
    # What if an exception occurs here?
    risky_operation()
finally:
    file.close()  # Might not be reached!
```

**Context Manager Approach (Safe):**
```python
# ‚úÖ Safe and clean way
with open('data.txt', 'w') as file:
    file.write('Hello, World!')
    risky_operation()
# File is ALWAYS closed, even if exception occurs!
```

---

## Built-in Context Managers

Python provides several built-in context managers for common use cases:

### File Operations

```python
# Reading files
with open('input.txt', 'r') as file:
    content = file.read()
    print(content)

# Writing files
with open('output.txt', 'w') as file:
    file.write('Python Context Managers Rock!')

# Binary files
with open('image.jpg', 'rb') as binary_file:
    data = binary_file.read()
```

```ascii
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ           File Context Manager              ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ                                             ‚îÇ
‚îÇ  open('file.txt') ‚Üí __enter__() ‚Üí file obj  ‚îÇ
‚îÇ                                             ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îÇ
‚îÇ  ‚îÇ          with block                     ‚îÇ ‚îÇ
‚îÇ  ‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îÇ ‚îÇ
‚îÇ  ‚îÇ  ‚îÇ file.read()                     ‚îÇ    ‚îÇ ‚îÇ
‚îÇ  ‚îÇ  ‚îÇ file.write()                    ‚îÇ    ‚îÇ ‚îÇ
‚îÇ  ‚îÇ  ‚îÇ # Other file operations         ‚îÇ    ‚îÇ ‚îÇ
‚îÇ  ‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îÇ ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îÇ
‚îÇ                                             ‚îÇ
‚îÇ  file.close() ‚Üê __exit__() ‚Üê Auto cleanup   ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### Threading Locks

```python
import threading

# Thread lock context manager
lock = threading.Lock()

with lock:
    # Critical section - only one thread can execute this
    shared_resource += 1
    print(f"Modified shared resource: {shared_resource}")
```

### Database Connections

```python
import sqlite3

# Database connection context manager
with sqlite3.connect('example.db') as conn:
    cursor = conn.cursor()
    cursor.execute("CREATE TABLE IF NOT EXISTS users (id INTEGER, name TEXT)")
    cursor.execute("INSERT INTO users VALUES (1, 'Alice')")
    # Connection is automatically committed and closed
```

---

## Creating Custom Context Managers

There are two primary ways to create custom context managers:

### Class-Based Approach

This is the traditional method using `__enter__` and `__exit__` methods:

```python
class DatabaseConnection:
    def __init__(self, database_url):
        self.database_url = database_url
        self.connection = None
    
    def __enter__(self):
        """Setup: Connect to database"""
        print(f"üîå Connecting to {self.database_url}")
        self.connection = self._connect()
        return self.connection
    
    def __exit__(self, exc_type, exc_value, traceback):
        """Cleanup: Close database connection"""
        if self.connection:
            if exc_type:
                print(f"‚ùå Error occurred: {exc_value}")
                self.connection.rollback()
            else:
                print("‚úÖ Transaction completed successfully")
                self.connection.commit()
            
            self.connection.close()
            print("üîê Database connection closed")
        
        # Return False to propagate exceptions
        return False
    
    def _connect(self):
        # Simulate database connection
        return f"Connection to {self.database_url}"

# Usage
with DatabaseConnection("postgresql://localhost:5432/mydb") as conn:
    print(f"Using connection: {conn}")
    # Your database operations here
```

```ascii
‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
‚ïë             Class-Based Context Manager            ‚ïë
‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£
‚ïë                                                    ‚ïë
‚ïë  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚ïë
‚ïë  ‚îÇ class MyContext:                             ‚îÇ  ‚ïë
‚ïë  ‚îÇ                                              ‚îÇ  ‚ïë
‚ïë  ‚îÇ   def __init__(self, config):                ‚îÇ  ‚ïë
‚ïë  ‚îÇ       self.config = config                   ‚îÇ  ‚ïë
‚ïë  ‚îÇ                                              ‚îÇ  ‚ïë
‚ïë  ‚îÇ   def __enter__(self):                       ‚îÇ  ‚ïë
‚ïë  ‚îÇ       # üöÄ Resource acquisition              ‚îÇ  ‚ïë
‚ïë  ‚îÇ       self.resource = acquire(self.config)   ‚îÇ  ‚ïë
‚ïë  ‚îÇ       return self.resource                   ‚îÇ  ‚ïë
‚ïë  ‚îÇ                                              ‚îÇ  ‚ïë
‚ïë  ‚îÇ   def __exit__(self, exc_type, exc_val,      ‚îÇ  ‚ïë
‚ïë  ‚îÇ                      exc_tb):                ‚îÇ  ‚ïë
‚ïë  ‚îÇ       # üßπ Resource cleanup                  ‚îÇ  ‚ïë
‚ïë  ‚îÇ       release(self.resource)                 ‚îÇ  ‚ïë
‚ïë  ‚îÇ       return False  # Don't suppress         ‚îÇ  ‚ïë
‚ïë  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚ïë
‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù
```

### Generator-Based Approach

Using the `@contextmanager` decorator for cleaner, more readable code:

```python
from contextlib import contextmanager
import tempfile
import os

@contextmanager
def temporary_directory():
    """Create a temporary directory and clean it up afterwards"""
    # Setup phase (equivalent to __enter__)
    temp_dir = tempfile.mkdtemp()
    print(f"üìÅ Created temporary directory: {temp_dir}")
    
    try:
        # Yield the resource to the with block
        yield temp_dir
    finally:
        # Cleanup phase (equivalent to __exit__)
        import shutil
        shutil.rmtree(temp_dir)
        print(f"üóëÔ∏è  Removed temporary directory: {temp_dir}")

# Usage
with temporary_directory() as temp_dir:
    # Create some files in the temporary directory
    temp_file = os.path.join(temp_dir, "example.txt")
    with open(temp_file, 'w') as f:
        f.write("This is a temporary file!")
    print(f"Working in: {temp_dir}")
```

```ascii
‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
‚ïë          Generator-Based Context Manager           ‚ïë
‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£
‚ïë                                                    ‚ïë
‚ïë  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚ïë
‚ïë  ‚îÇ from contextlib import contextmanager        ‚îÇ  ‚ïë
‚ïë  ‚îÇ                                              ‚îÇ  ‚ïë
‚ïë  ‚îÇ @contextmanager                              ‚îÇ  ‚ïë
‚ïë  ‚îÇ def my_context():                            ‚îÇ  ‚ïë
‚ïë  ‚îÇ     # üöÄ Setup phase                         ‚îÇ  ‚ïë
‚ïë  ‚îÇ     resource = acquire_resource()            ‚îÇ  ‚ïë
‚ïë  ‚îÇ                                              ‚îÇ  ‚ïë
‚ïë  ‚îÇ     try:                                     ‚îÇ  ‚ïë
‚ïë  ‚îÇ         yield resource  # üéØ Return to with  ‚îÇ  ‚ïë
‚ïë  ‚îÇ     finally:                                 ‚îÇ  ‚ïë
‚ïë  ‚îÇ         # üßπ Cleanup phase                   ‚îÇ  ‚ïë
‚ïë  ‚îÇ         release_resource(resource)           ‚îÇ  ‚ïë
‚ïë  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚ïë
‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù
```

### Exception Handling in Context Managers

Context managers can handle exceptions gracefully:

```python
@contextmanager
def error_handler():
    """Context manager that handles and logs errors"""
    try:
        print("üõ°Ô∏è  Error protection activated")
        yield
    except ValueError as e:
        print(f"‚ö†Ô∏è  ValueError caught and handled: {e}")
        # Return True to suppress the exception
        return True
    except Exception as e:
        print(f"üí• Unexpected error: {e}")
        # Return False or don't return to propagate
        raise
    finally:
        print("üîö Error protection deactivated")

# Usage
with error_handler():
    print("This will work fine")
    raise ValueError("This error will be caught!")
    print("This line won't be reached")

print("Program continues normally!")
```

---

## The contextlib Module

The `contextlib` module provides powerful utilities for working with context managers:

### `@contextmanager` Decorator

We've already seen this - it's the most commonly used utility:

```python
from contextlib import contextmanager

@contextmanager
def timer():
    """Simple timing context manager"""
    import time
    start = time.time()
    print("‚è±Ô∏è  Timer started")
    
    try:
        yield
    finally:
        end = time.time()
        print(f"‚è±Ô∏è  Elapsed time: {end - start:.4f} seconds")

# Usage
with timer():
    import time
    time.sleep(1)
    print("Some work done!")
```

### `contextlib.closing()`

Automatically calls `close()` on objects:

```python
from contextlib import closing
from urllib.request import urlopen

# Automatically close the URL connection
with closing(urlopen('http://httpbin.org/json')) as page:
    content = page.read()
    print(f"üì• Downloaded {len(content)} bytes")
```

### `contextlib.suppress()`

Suppress specific exceptions:

```python
from contextlib import suppress
import os

# Suppress FileNotFoundError when removing files
with suppress(FileNotFoundError):
    os.remove('nonexistent_file.txt')
    print("File removed (if it existed)")

print("Program continues regardless!")
```

```ascii
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ            contextlib.suppress()                ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ                                                 ‚îÇ
‚îÇ  with suppress(FileNotFoundError, OSError):     ‚îÇ
‚îÇ      ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îÇ
‚îÇ      ‚îÇ  os.remove('file1.txt')                 ‚îÇ ‚îÇ
‚îÇ      ‚îÇ  os.remove('file2.txt')                 ‚îÇ ‚îÇ
‚îÇ      ‚îÇ  risky_operation()                      ‚îÇ ‚îÇ
‚îÇ      ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îÇ
‚îÇ  # Specified exceptions are silently ignored    ‚îÇ
‚îÇ  # Other exceptions still propagate             ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### `contextlib.redirect_stdout()` and `redirect_stderr()`

Redirect standard output streams:

```python
from contextlib import redirect_stdout, redirect_stderr
import io

# Capture stdout
output_buffer = io.StringIO()

with redirect_stdout(output_buffer):
    print("This goes to the buffer!")
    print("So does this!")

captured_output = output_buffer.getvalue()
print(f"Captured: {repr(captured_output)}")

# Redirect to file
with open('output.log', 'w') as log_file:
    with redirect_stdout(log_file):
        print("This goes to the log file!")
        help(len)  # Help text goes to file
```

### `contextlib.ExitStack`

Manage multiple context managers dynamically:

```python
from contextlib import ExitStack
import tempfile

def process_files(filenames):
    """Process multiple files using ExitStack"""
    with ExitStack() as stack:
        # Open all files
        files = [
            stack.enter_context(open(fname, 'r'))
            for fname in filenames
        ]
        
        # Register cleanup callbacks
        temp_dir = tempfile.mkdtemp()
        stack.callback(lambda: print(f"üóëÔ∏è  Cleanup: {temp_dir}"))
        
        # Process all files
        for i, file in enumerate(files):
            content = file.read()
            print(f"üìÑ File {i+1}: {len(content)} characters")

# Usage
process_files(['file1.txt', 'file2.txt', 'file3.txt'])
```

```ascii
‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
‚ïë                 ExitStack                        ‚ïë
‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£
‚ïë                                                  ‚ïë
‚ïë  with ExitStack() as stack:                      ‚ïë
‚ïë      ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚ïë
‚ïë      ‚îÇ file1 = stack.enter_context(open(...)) ‚îÇ ‚ïë
‚ïë      ‚îÇ file2 = stack.enter_context(open(...)) ‚îÇ ‚ïë
‚ïë      ‚îÇ stack.callback(cleanup_function)       ‚îÇ ‚ïë
‚ïë      ‚îÇ                                         ‚îÇ ‚ïë
‚ïë      ‚îÇ # All resources managed together        ‚îÇ ‚ïë
‚ïë      ‚îÇ # Cleanup happens in reverse order     ‚îÇ ‚ïë
‚ïë      ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚ïë
‚ïë                                                  ‚ïë
‚ïë  Stack cleanup order: callback ‚Üí file2 ‚Üí file1  ‚ïë
‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù
```

### `contextlib.nullcontext()`

A no-op context manager for conditional context management:

```python
from contextlib import nullcontext

def process_data(data, use_lock=False):
    """Conditionally use a lock"""
    import threading
    
    lock = threading.Lock() if use_lock else nullcontext()
    
    with lock:
        # Process data (with or without locking)
        print(f"Processing {len(data)} items")
        return [item.upper() for item in data]

# Usage
result1 = process_data(['a', 'b', 'c'], use_lock=True)   # With lock
result2 = process_data(['x', 'y', 'z'], use_lock=False)  # Without lock
```

---

## Advanced Context Management

### Nested Context Managers

You can nest multiple context managers:

```python
# Multiple context managers in one statement
with open('input.txt', 'r') as infile, open('output.txt', 'w') as outfile:
    content = infile.read()
    outfile.write(content.upper())

# Nested with statements
with tempfile.TemporaryDirectory() as temp_dir:
    temp_file = os.path.join(temp_dir, 'data.txt')
    
    with open(temp_file, 'w') as file:
        file.write("Nested context managers!")
        
        with timer():
            # Triple nesting!
            time.sleep(0.5)
```

### Context Manager as Decorator

Context managers can also be used as decorators:

```python
from contextlib import ContextDecorator

class benchmark(ContextDecorator):
    """Benchmark function execution time"""
    
    def __enter__(self):
        import time
        self.start_time = time.time()
        print("üèÅ Benchmark started")
        return self
    
    def __exit__(self, exc_type, exc_value, traceback):
        import time
        end_time = time.time()
        elapsed = end_time - self.start_time
        print(f"‚è±Ô∏è  Execution time: {elapsed:.4f} seconds")
        return False

# Use as context manager
with benchmark():
    time.sleep(1)

# Use as decorator
@benchmark()
def slow_function():
    time.sleep(0.5)
    return "Done!"

result = slow_function()
```

### Reusable Context Managers

Some context managers can be reused, others cannot:

```python
# Reusable context manager
lock = threading.Lock()

with lock:
    print("First use")

with lock:
    print("Second use - OK!")

# Single-use context manager
@contextmanager
def single_use():
    print("Setup")
    yield
    print("Cleanup")

cm = single_use()
with cm:
    print("First use")

# This will raise RuntimeError: generator didn't yield
# with cm:
#     print("Second use - ERROR!")
```

---

## Asynchronous Context Managers

For asynchronous programming, Python provides async context managers:

### `async with` Statement

```python
import asyncio
from contextlib import asynccontextmanager

@asynccontextmanager
async def async_database_connection():
    """Async database connection context manager"""
    print("üîå Connecting to async database...")
    # Simulate async connection
    await asyncio.sleep(0.1)
    connection = "Async DB Connection"
    
    try:
        yield connection
    finally:
        print("üîê Closing async database connection...")
        await asyncio.sleep(0.1)

async def main():
    async with async_database_connection() as conn:
        print(f"Using {conn}")
        await asyncio.sleep(0.2)  # Simulate async work

# Run the async function
# asyncio.run(main())
```

### `contextlib.aclosing()`

For async resources that need closing:

```python
from contextlib import aclosing

async def async_generator():
    """Async generator that needs cleanup"""
    try:
        for i in range(5):
            yield f"Item {i}"
            await asyncio.sleep(0.1)
    finally:
        print("üßπ Async generator cleaned up")

async def process_async_data():
    async with aclosing(async_generator()) as agen:
        async for item in agen:
            print(f"üì¶ Received: {item}")
            if item == "Item 2":
                break  # Early exit triggers cleanup

# asyncio.run(process_async_data())
```

```ascii
‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
‚ïë              Async Context Managers                ‚ïë
‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£
‚ïë                                                    ‚ïë
‚ïë  async with async_context_manager() as resource:   ‚ïë
‚ïë      ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê   ‚ïë
‚ïë      ‚îÇ await __aenter__()  # Setup             ‚îÇ   ‚ïë
‚ïë      ‚îÇ resource = returned_value               ‚îÇ   ‚ïë
‚ïë      ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò   ‚ïë
‚ïë                                                    ‚ïë
‚ïë      ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê   ‚ïë
‚ïë      ‚îÇ # Async operations with resource        ‚îÇ   ‚ïë
‚ïë      ‚îÇ await some_async_operation(resource)    ‚îÇ   ‚ïë
‚ïë      ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò   ‚ïë
‚ïë                                                    ‚ïë
‚ïë      ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê   ‚ïë
‚ïë      ‚îÇ await __aexit__()  # Cleanup            ‚îÇ   ‚ïë
‚ïë      ‚îÇ # Always called, even on exceptions     ‚îÇ   ‚ïë
‚ïë      ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò   ‚ïë
‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù
```

---

## Best Practices and Patterns

### 1. Always Use Context Managers for Resources

```python
# ‚ùå DON'T do this
file = open('data.txt', 'r')
data = file.read()
file.close()  # Might be forgotten or not reached

# ‚úÖ DO this
with open('data.txt', 'r') as file:
    data = file.read()
# File automatically closed
```

### 2. Handle Exceptions Properly

```python
@contextmanager
def robust_context():
    """Context manager with proper exception handling"""
    resource = acquire_resource()
    try:
        yield resource
    except SpecificError as e:
        # Handle specific errors
        log_error(e)
        # Return True to suppress, False to propagate
        return False
    except Exception as e:
        # Handle unexpected errors
        log_critical_error(e)
        raise  # Always re-raise unexpected errors
    finally:
        # Cleanup always happens
        release_resource(resource)
```

### 3. Use `ExitStack` for Dynamic Resource Management

```python
def process_variable_files(filenames):
    """Handle variable number of files efficiently"""
    with ExitStack() as stack:
        files = []
        for filename in filenames:
            try:
                file = stack.enter_context(open(filename, 'r'))
                files.append(file)
            except FileNotFoundError:
                print(f"‚ö†Ô∏è  Skipping missing file: {filename}")
                continue
        
        # Process all successfully opened files
        for file in files:
            process_file(file)
```

### 4. Make Context Managers Descriptive

```python
@contextmanager
def timed_operation(operation_name):
    """Timer with descriptive operation name"""
    start_time = time.time()
    print(f"üöÄ Starting {operation_name}")
    
    try:
        yield
    finally:
        elapsed = time.time() - start_time
        print(f"‚úÖ {operation_name} completed in {elapsed:.2f}s")

# Usage is self-documenting
with timed_operation("Database migration"):
    migrate_database()

with timed_operation("File processing"):
    process_large_file()
```

---

## Real-World Examples

### 1. Configuration Manager

```python
@contextmanager
def config_override(**overrides):
    """Temporarily override configuration values"""
    original_values = {}
    
    # Save original values and apply overrides
    for key, value in overrides.items():
        if hasattr(config, key):
            original_values[key] = getattr(config, key)
        setattr(config, key, value)
    
    try:
        yield config
    finally:
        # Restore original values
        for key, value in original_values.items():
            setattr(config, key, value)
        
        # Remove new keys that didn't exist before
        for key in overrides:
            if key not in original_values:
                delattr(config, key)

# Usage
with config_override(debug=True, log_level='DEBUG'):
    run_debug_operations()
# Configuration automatically restored
```

### 2. Performance Monitor

```python
@contextmanager
def performance_monitor(threshold_seconds=1.0):
    """Monitor performance and warn if threshold exceeded"""
    import psutil
    import time
    
    process = psutil.Process()
    start_time = time.time()
    start_memory = process.memory_info().rss
    start_cpu = process.cpu_percent()
    
    try:
        yield
    finally:
        end_time = time.time()
        end_memory = process.memory_info().rss
        end_cpu = process.cpu_percent()
        
        elapsed = end_time - start_time
        memory_diff = (end_memory - start_memory) / 1024 / 1024  # MB
        
        print(f"üìä Performance Report:")
        print(f"   ‚è±Ô∏è  Time: {elapsed:.3f}s")
        print(f"   üß† Memory: {memory_diff:+.2f} MB")
        print(f"   üñ•Ô∏è  CPU: {end_cpu:.1f}%")
        
        if elapsed > threshold_seconds:
            print(f"‚ö†Ô∏è  WARNING: Operation exceeded {threshold_seconds}s threshold!")

# Usage
with performance_monitor(threshold_seconds=0.5):
    # Your code here
    expensive_operation()
```

### 3. API Rate Limiter

```python
import time
from collections import defaultdict

class RateLimiter:
    def __init__(self):
        self.requests = defaultdict(list)
    
    @contextmanager
    def limit(self, key, max_requests, window_seconds):
        """Rate limiting context manager"""
        now = time.time()
        
        # Clean old requests
        self.requests[key] = [
            req_time for req_time in self.requests[key]
            if now - req_time < window_seconds
        ]
        
        # Check if we can make a request
        if len(self.requests[key]) >= max_requests:
            wait_time = window_seconds - (now - self.requests[key][0])
            print(f"üõë Rate limit exceeded. Waiting {wait_time:.1f}s...")
            time.sleep(wait_time)
        
        # Record this request
        self.requests[key].append(now)
        
        try:
            yield
        except Exception as e:
            # Remove the request on failure
            if self.requests[key]:
                self.requests[key].pop()
            raise

# Usage
limiter = RateLimiter()

def api_call(user_id, data):
    with limiter.limit(f"user:{user_id}", max_requests=5, window_seconds=60):
        # Make API call
        print(f"üåê Making API call for user {user_id}")
        return f"Response for {data}"
```

---

## Common Pitfalls and Solutions

### 1. Forgetting to Handle Exceptions in `__exit__`

```python
# ‚ùå WRONG - exceptions in __exit__ can mask original exceptions
class BadContextManager:
    def __exit__(self, exc_type, exc_value, traceback):
        risky_cleanup()  # If this raises, original exception is lost!

# ‚úÖ CORRECT - protect cleanup operations
class GoodContextManager:
    def __exit__(self, exc_type, exc_value, traceback):
        try:
            risky_cleanup()
        except Exception as cleanup_error:
            if exc_type is None:
                # No original exception, re-raise cleanup error
                raise cleanup_error
            else:
                # Original exception takes precedence
                print(f"Cleanup error ignored: {cleanup_error}")
        return False  # Don't suppress original exception
```

### 2. Not Making Context Managers Reentrant When Needed

```python
import threading

class ReentrantContextManager:
    def __init__(self):
        self.lock = threading.RLock()  # Reentrant lock
        self.count = 0
    
    def __enter__(self):
        self.lock.acquire()
        self.count += 1
        print(f"üîí Lock acquired (depth: {self.count})")
        return self
    
    def __exit__(self, exc_type, exc_value, traceback):
        self.count -= 1
        print(f"üîì Lock released (depth: {self.count})")
        self.lock.release()
        return False

# Can be used in nested calls
manager = ReentrantContextManager()

def nested_function():
    with manager:
        print("Inner function")

def outer_function():
    with manager:
        print("Outer function")
        nested_function()  # This works because it's reentrant

outer_function()
```

### 3. Resource Leaks in Generators

```python
# ‚ùå POTENTIAL PROBLEM - generator not fully consumed
@contextmanager
def resource_manager():
    resource = acquire_expensive_resource()
    try:
        yield resource
    finally:
        release_expensive_resource(resource)

def problematic_usage():
    with resource_manager() as resource:
        for item in some_generator():
            if condition_met(item):
                return item  # Early return - cleanup still happens!
        # This is fine - context manager handles cleanup

# ‚úÖ SOLUTION - context managers handle early exits correctly
def safe_usage():
    with resource_manager() as resource:
        # Even with early returns, exceptions, or breaks,
        # the finally block in the context manager runs
        return process_with_resource(resource)
```

---

## Performance Considerations

### Context Manager Overhead

Context managers have minimal overhead, but here are some considerations:

```python
import time

# Measuring context manager overhead
def measure_overhead():
    # Without context manager
    start = time.perf_counter()
    for _ in range(100000):
        file = open('/dev/null', 'w')
        file.close()
    no_context_time = time.perf_counter() - start
    
    # With context manager
    start = time.perf_counter()
    for _ in range(100000):
        with open('/dev/null', 'w') as file:
            pass
    context_time = time.perf_counter() - start
    
    print(f"Without context manager: {no_context_time:.4f}s")
    print(f"With context manager: {context_time:.4f}s")
    print(f"Overhead: {((context_time - no_context_time) / no_context_time) * 100:.2f}%")

# The overhead is typically negligible (< 5%)
```

### Optimizing Custom Context Managers

```python
# ‚úÖ Efficient context manager
@contextmanager
def efficient_manager():
    # Minimize work in setup
    resource = quick_acquire()
    
    try:
        yield resource
    finally:
        # Defer expensive cleanup if possible
        schedule_cleanup(resource)  # Non-blocking

# ‚ùå Inefficient context manager
@contextmanager
def inefficient_manager():
    # Expensive setup
    resource = expensive_acquire()
    
    try:
        yield resource
    finally:
        # Blocking cleanup
        expensive_cleanup(resource)  # Blocks until complete
```

---

## Interactive Examples and Exercises

### Exercise 1: Create a Logging Context Manager

```python
@contextmanager
def log_activity(activity_name, log_level="INFO"):
    """Log the start and end of an activity"""
    import logging
    
    # TODO: Implement this context manager
    # - Log start of activity
    # - Handle exceptions and log them
    # - Log end of activity with duration
    pass

# Test your implementation
with log_activity("Database backup", "DEBUG"):
    time.sleep(1)  # Simulate work
    print("Backup completed!")
```

**Solution:**
```python
@contextmanager
def log_activity(activity_name, log_level="INFO"):
    import logging
    import time
    
    logger = logging.getLogger(__name__)
    start_time = time.time()
    
    logger.log(getattr(logging, log_level), f"üöÄ Starting: {activity_name}")
    
    try:
        yield
    except Exception as e:
        logger.error(f"‚ùå Failed: {activity_name} - {e}")
        raise
    else:
        duration = time.time() - start_time
        logger.log(getattr(logging, log_level), 
                  f"‚úÖ Completed: {activity_name} ({duration:.2f}s)")
```

### Exercise 2: File Backup Context Manager

```python
@contextmanager
def backup_on_write(filename):
    """Create a backup before writing to a file"""
    # TODO: Implement backup functionality
    # - Create backup of existing file (if it exists)
    # - Yield file handle for writing
    # - Handle errors (restore backup if write fails)
    pass

# Test your implementation
with backup_on_write("important_data.txt") as file:
    file.write("New important data!")
```

---

## Summary and Key Takeaways

```ascii
‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
‚ïë              Context Manager Mastery                ‚ïë
‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£
‚ïë                                                      ‚ïë
‚ïë  üéØ Key Benefits:                                    ‚ïë
‚ïë     ‚Ä¢ Automatic resource management                  ‚ïë
‚ïë     ‚Ä¢ Exception safety                               ‚ïë
‚ïë     ‚Ä¢ Cleaner, more readable code                    ‚ïë
‚ïë     ‚Ä¢ Reduced boilerplate                            ‚ïë
‚ïë                                                      ‚ïë
‚ïë  üõ†Ô∏è  Implementation Methods:                         ‚ïë
‚ïë     ‚Ä¢ Class-based (__enter__, __exit__)              ‚ïë
‚ïë     ‚Ä¢ Generator-based (@contextmanager)              ‚ïë
‚ïë     ‚Ä¢ Built-in utilities (contextlib)                ‚ïë
‚ïë                                                      ‚ïë
‚ïë  üöÄ Advanced Features:                               ‚ïë
‚ïë     ‚Ä¢ ExitStack for dynamic management               ‚ïë
‚ïë     ‚Ä¢ Async context managers                         ‚ïë
‚ïë     ‚Ä¢ Context managers as decorators                 ‚ïë
‚ïë                                                      ‚ïë
‚ïë  üí° Best Practices:                                  ‚ïë
‚ïë     ‚Ä¢ Always handle exceptions properly              ‚ïë
‚ïë     ‚Ä¢ Make cleanup operations safe                   ‚ïë
‚ïë     ‚Ä¢ Use descriptive names                          ‚ïë
‚ïë     ‚Ä¢ Consider reusability and reentrancy            ‚ïë
‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù
```

### When to Use Context Managers

- **File operations**: Always use `with open()`
- **Resource management**: Database connections, network sockets
- **Lock management**: Thread synchronization
- **Temporary changes**: Configuration overrides, directory changes
- **Exception handling**: Suppressing specific errors
- **Timing and monitoring**: Performance measurement
- **Cleanup operations**: Temporary files, cache clearing

### Common Patterns

1. **Resource Acquisition/Release**: Files, connections, locks
2. **State Save/Restore**: Configuration, environment variables
3. **Setup/Teardown**: Test fixtures, temporary resources
4. **Enter/Exit Logging**: Activity tracking, debugging
5. **Exception Management**: Error suppression, custom handling

---

## Conclusion

Context managers are a fundamental feature of Python that promote clean, safe, and maintainable code. They embody Python's philosophy of making common patterns easy to implement and hard to get wrong.

Key takeaways:
- Use context managers for any resource that needs cleanup
- Prefer `@contextmanager` for simple cases, classes for complex ones
- Always handle exceptions properly in `__exit__` methods
- Leverage `contextlib` utilities for common patterns
- Consider using `ExitStack` for dynamic resource management

```ascii
üéâ Congratulations! You've mastered Python Context Managers! üéâ

‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  "With great power comes great responsibility"       ‚îÇ
‚îÇ  - Use context managers wisely and your code        ‚îÇ
‚îÇ    will be more robust, readable, and maintainable! ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

Next steps:
‚Ä¢ Practice implementing custom context managers
‚Ä¢ Explore async context managers for asyncio code
‚Ä¢ Check out contextlib source code for inspiration
‚Ä¢ Use context managers in your next Python project!
```

---

*Happy coding with Python Context Managers! üêç‚ú®*

---

## Additional Resources

- [Official Python Documentation - contextlib](https://docs.python.org/3/library/contextlib.html)
- [PEP 343 - The "with" Statement](https://www.python.org/dev/peps/pep-0343/)
- [Real Python - Context Managers Guide](https://realpython.com/python-with-statement/)
- [Python Context Managers Best Practices](https://docs.python-guide.org/writing/structure/#context-managers)

---

**Created with ‚ù§Ô∏è for Python developers who want to write better, safer code!**