# Python Context Managers: The Complete Guide 🐍✨

*Mastering Resource Management with Professional Style and Visual ASCII Art*

---

## Table of Contents

- [Introduction](#introduction)
- [What Are Context Managers?](#what-are-context-managers)
- [The `with` Statement Magic](#the-with-statement-magic)
- [Built-in Context Managers](#built-in-context-managers)
- [Creating Custom Context Managers](#creating-custom-context-managers)
  - [Class-Based Approach](#class-based-approach)
  - [Generator-Based Approach](#generator-based-approach)
- [The contextlib Module](#the-contextlib-module)
- [Advanced Context Management](#advanced-context-management)
- [Asynchronous Context Managers](#asynchronous-context-managers)
- [Best Practices and Patterns](#best-practices-and-patterns)
- [Real-World Examples](#real-world-examples)
- [Common Pitfalls and Solutions](#common-pitfalls-and-solutions)
- [Performance Considerations](#performance-considerations)
- [Conclusion](#conclusion)

---

## Introduction

Welcome to the comprehensive world of **Python Context Managers**! 🎯

Context managers are one of Python's most elegant features for resource management. They provide a clean, reliable way to handle resources that need proper setup and cleanup, ensuring your code is both robust and maintainable.

```ascii
┌─────────────────────────────────────────────┐
│           Context Manager Flow               │
├─────────────────────────────────────────────┤
│  ┌─────────┐    ┌──────────┐    ┌─────────┐  │
│  │ __enter__│ →  │   with   │ →  │__exit__ │  │
│  │  Setup   │    │  block   │    │Cleanup  │  │
│  └─────────┘    └──────────┘    └─────────┘  │
└─────────────────────────────────────────────┘
```

---

## What Are Context Managers?

**Context Managers** are Python objects that define methods to be used with the `with` statement. They implement the **context management protocol** which consists of two special methods:

- `__enter__()`: Sets up the context and returns a resource
- `__exit__()`: Cleans up the context, even if an exception occurs

```ascii
╔══════════════════════════════════════════════╗
║               Context Manager                ║
║                                              ║
║  ┌─────────────────────────────────────────┐ ║
║  │ class MyContextManager:                 │ ║
║  │     def __enter__(self):                │ ║
║  │         # Setup resource                │ ║
║  │         return resource                 │ ║
║  │                                         │ ║
║  │     def __exit__(self, exc_type,        │ ║
║  │                        exc_val,         │ ║
║  │                        exc_tb):         │ ║
║  │         # Cleanup resource              │ ║
║  │         return False                    │ ║
║  └─────────────────────────────────────────┘ ║
╚══════════════════════════════════════════════╝
```

### Why Context Managers Matter

1. **Automatic Resource Management**: Ensures resources are properly released
2. **Exception Safety**: Cleanup happens even if exceptions occur
3. **Cleaner Code**: Eliminates repetitive try/finally blocks
4. **Pythonic**: Following Python's philosophy of readable, maintainable code

---

## The `with` Statement Magic

The `with` statement is the gateway to context managers. Here's how it works:

```python
with context_manager() as resource:
    # Use the resource
    do_something_with(resource)
# Resource is automatically cleaned up here
```

```ascii
┌─────────────────────────────────────────────────────┐
│                 WITH Statement Flow                 │
├─────────────────────────────────────────────────────┤
│                                                     │
│  1. with expression as target:                      │
│     ┌─────────────────────────────────────────────┐ │
│     │ __enter__() is called                       │ │
│     │ Result assigned to 'target'                 │ │
│     └─────────────────────────────────────────────┘ │
│                                                     │
│  2. with block execution:                           │
│     ┌─────────────────────────────────────────────┐ │
│     │ Your code runs here                         │ │
│     │ Can raise exceptions                        │ │
│     └─────────────────────────────────────────────┘ │
│                                                     │
│  3. Block exit (normal or exception):               │
│     ┌─────────────────────────────────────────────┐ │
│     │ __exit__() is ALWAYS called                 │ │
│     │ Exception info passed if any                │ │
│     └─────────────────────────────────────────────┘ │
└─────────────────────────────────────────────────────┘
```

### Traditional vs Context Manager Approach

**Traditional Approach (Error-Prone):**
```python
# ❌ Error-prone way
file = open('data.txt', 'w')
try:
    file.write('Hello, World!')
    # What if an exception occurs here?
    risky_operation()
finally:
    file.close()  # Might not be reached!
```

**Context Manager Approach (Safe):**
```python
# ✅ Safe and clean way
with open('data.txt', 'w') as file:
    file.write('Hello, World!')
    risky_operation()
# File is ALWAYS closed, even if exception occurs!
```

---

## Built-in Context Managers

Python provides several built-in context managers for common use cases:

### File Operations

```python
# Reading files
with open('input.txt', 'r') as file:
    content = file.read()
    print(content)

# Writing files
with open('output.txt', 'w') as file:
    file.write('Python Context Managers Rock!')

# Binary files
with open('image.jpg', 'rb') as binary_file:
    data = binary_file.read()
```

```ascii
┌─────────────────────────────────────────────┐
│           File Context Manager              │
├─────────────────────────────────────────────┤
│                                             │
│  open('file.txt') → __enter__() → file obj  │
│                                             │
│  ┌─────────────────────────────────────────┐ │
│  │          with block                     │ │
│  │  ┌─────────────────────────────────┐    │ │
│  │  │ file.read()                     │    │ │
│  │  │ file.write()                    │    │ │
│  │  │ # Other file operations         │    │ │
│  │  └─────────────────────────────────┘    │ │
│  └─────────────────────────────────────────┘ │
│                                             │
│  file.close() ← __exit__() ← Auto cleanup   │
└─────────────────────────────────────────────┘
```

### Threading Locks

```python
import threading

# Thread lock context manager
lock = threading.Lock()

with lock:
    # Critical section - only one thread can execute this
    shared_resource += 1
    print(f"Modified shared resource: {shared_resource}")
```

### Database Connections

```python
import sqlite3

# Database connection context manager
with sqlite3.connect('example.db') as conn:
    cursor = conn.cursor()
    cursor.execute("CREATE TABLE IF NOT EXISTS users (id INTEGER, name TEXT)")
    cursor.execute("INSERT INTO users VALUES (1, 'Alice')")
    # Connection is automatically committed and closed
```

---

## Creating Custom Context Managers

There are two primary ways to create custom context managers:

### Class-Based Approach

This is the traditional method using `__enter__` and `__exit__` methods:

```python
class DatabaseConnection:
    def __init__(self, database_url):
        self.database_url = database_url
        self.connection = None
    
    def __enter__(self):
        """Setup: Connect to database"""
        print(f"🔌 Connecting to {self.database_url}")
        self.connection = self._connect()
        return self.connection
    
    def __exit__(self, exc_type, exc_value, traceback):
        """Cleanup: Close database connection"""
        if self.connection:
            if exc_type:
                print(f"❌ Error occurred: {exc_value}")
                self.connection.rollback()
            else:
                print("✅ Transaction completed successfully")
                self.connection.commit()
            
            self.connection.close()
            print("🔐 Database connection closed")
        
        # Return False to propagate exceptions
        return False
    
    def _connect(self):
        # Simulate database connection
        return f"Connection to {self.database_url}"

# Usage
with DatabaseConnection("postgresql://localhost:5432/mydb") as conn:
    print(f"Using connection: {conn}")
    # Your database operations here
```

```ascii
╔════════════════════════════════════════════════════╗
║             Class-Based Context Manager            ║
╠════════════════════════════════════════════════════╣
║                                                    ║
║  ┌──────────────────────────────────────────────┐  ║
║  │ class MyContext:                             │  ║
║  │                                              │  ║
║  │   def __init__(self, config):                │  ║
║  │       self.config = config                   │  ║
║  │                                              │  ║
║  │   def __enter__(self):                       │  ║
║  │       # 🚀 Resource acquisition              │  ║
║  │       self.resource = acquire(self.config)   │  ║
║  │       return self.resource                   │  ║
║  │                                              │  ║
║  │   def __exit__(self, exc_type, exc_val,      │  ║
║  │                      exc_tb):                │  ║
║  │       # 🧹 Resource cleanup                  │  ║
║  │       release(self.resource)                 │  ║
║  │       return False  # Don't suppress         │  ║
║  └──────────────────────────────────────────────┘  ║
╚════════════════════════════════════════════════════╝
```

### Generator-Based Approach

Using the `@contextmanager` decorator for cleaner, more readable code:

```python
from contextlib import contextmanager
import tempfile
import os

@contextmanager
def temporary_directory():
    """Create a temporary directory and clean it up afterwards"""
    # Setup phase (equivalent to __enter__)
    temp_dir = tempfile.mkdtemp()
    print(f"📁 Created temporary directory: {temp_dir}")
    
    try:
        # Yield the resource to the with block
        yield temp_dir
    finally:
        # Cleanup phase (equivalent to __exit__)
        import shutil
        shutil.rmtree(temp_dir)
        print(f"🗑️  Removed temporary directory: {temp_dir}")

# Usage
with temporary_directory() as temp_dir:
    # Create some files in the temporary directory
    temp_file = os.path.join(temp_dir, "example.txt")
    with open(temp_file, 'w') as f:
        f.write("This is a temporary file!")
    print(f"Working in: {temp_dir}")
```

```ascii
╔════════════════════════════════════════════════════╗
║          Generator-Based Context Manager           ║
╠════════════════════════════════════════════════════╣
║                                                    ║
║  ┌──────────────────────────────────────────────┐  ║
║  │ from contextlib import contextmanager        │  ║
║  │                                              │  ║
║  │ @contextmanager                              │  ║
║  │ def my_context():                            │  ║
║  │     # 🚀 Setup phase                         │  ║
║  │     resource = acquire_resource()            │  ║
║  │                                              │  ║
║  │     try:                                     │  ║
║  │         yield resource  # 🎯 Return to with  │  ║
║  │     finally:                                 │  ║
║  │         # 🧹 Cleanup phase                   │  ║
║  │         release_resource(resource)           │  ║
║  └──────────────────────────────────────────────┘  ║
╚════════════════════════════════════════════════════╝
```

### Exception Handling in Context Managers

Context managers can handle exceptions gracefully:

```python
@contextmanager
def error_handler():
    """Context manager that handles and logs errors"""
    try:
        print("🛡️  Error protection activated")
        yield
    except ValueError as e:
        print(f"⚠️  ValueError caught and handled: {e}")
        # Return True to suppress the exception
        return True
    except Exception as e:
        print(f"💥 Unexpected error: {e}")
        # Return False or don't return to propagate
        raise
    finally:
        print("🔚 Error protection deactivated")

# Usage
with error_handler():
    print("This will work fine")
    raise ValueError("This error will be caught!")
    print("This line won't be reached")

print("Program continues normally!")
```

---

## The contextlib Module

The `contextlib` module provides powerful utilities for working with context managers:

### `@contextmanager` Decorator

We've already seen this - it's the most commonly used utility:

```python
from contextlib import contextmanager

@contextmanager
def timer():
    """Simple timing context manager"""
    import time
    start = time.time()
    print("⏱️  Timer started")
    
    try:
        yield
    finally:
        end = time.time()
        print(f"⏱️  Elapsed time: {end - start:.4f} seconds")

# Usage
with timer():
    import time
    time.sleep(1)
    print("Some work done!")
```

### `contextlib.closing()`

Automatically calls `close()` on objects:

```python
from contextlib import closing
from urllib.request import urlopen

# Automatically close the URL connection
with closing(urlopen('http://httpbin.org/json')) as page:
    content = page.read()
    print(f"📥 Downloaded {len(content)} bytes")
```

### `contextlib.suppress()`

Suppress specific exceptions:

```python
from contextlib import suppress
import os

# Suppress FileNotFoundError when removing files
with suppress(FileNotFoundError):
    os.remove('nonexistent_file.txt')
    print("File removed (if it existed)")

print("Program continues regardless!")
```

```ascii
┌─────────────────────────────────────────────────┐
│            contextlib.suppress()                │
├─────────────────────────────────────────────────┤
│                                                 │
│  with suppress(FileNotFoundError, OSError):     │
│      ┌─────────────────────────────────────────┐ │
│      │  os.remove('file1.txt')                 │ │
│      │  os.remove('file2.txt')                 │ │
│      │  risky_operation()                      │ │
│      └─────────────────────────────────────────┘ │
│  # Specified exceptions are silently ignored    │
│  # Other exceptions still propagate             │
└─────────────────────────────────────────────────┘
```

### `contextlib.redirect_stdout()` and `redirect_stderr()`

Redirect standard output streams:

```python
from contextlib import redirect_stdout, redirect_stderr
import io

# Capture stdout
output_buffer = io.StringIO()

with redirect_stdout(output_buffer):
    print("This goes to the buffer!")
    print("So does this!")

captured_output = output_buffer.getvalue()
print(f"Captured: {repr(captured_output)}")

# Redirect to file
with open('output.log', 'w') as log_file:
    with redirect_stdout(log_file):
        print("This goes to the log file!")
        help(len)  # Help text goes to file
```

### `contextlib.ExitStack`

Manage multiple context managers dynamically:

```python
from contextlib import ExitStack
import tempfile

def process_files(filenames):
    """Process multiple files using ExitStack"""
    with ExitStack() as stack:
        # Open all files
        files = [
            stack.enter_context(open(fname, 'r'))
            for fname in filenames
        ]
        
        # Register cleanup callbacks
        temp_dir = tempfile.mkdtemp()
        stack.callback(lambda: print(f"🗑️  Cleanup: {temp_dir}"))
        
        # Process all files
        for i, file in enumerate(files):
            content = file.read()
            print(f"📄 File {i+1}: {len(content)} characters")

# Usage
process_files(['file1.txt', 'file2.txt', 'file3.txt'])
```

```ascii
╔══════════════════════════════════════════════════╗
║                 ExitStack                        ║
╠══════════════════════════════════════════════════╣
║                                                  ║
║  with ExitStack() as stack:                      ║
║      ┌─────────────────────────────────────────┐ ║
║      │ file1 = stack.enter_context(open(...)) │ ║
║      │ file2 = stack.enter_context(open(...)) │ ║
║      │ stack.callback(cleanup_function)       │ ║
║      │                                         │ ║
║      │ # All resources managed together        │ ║
║      │ # Cleanup happens in reverse order     │ ║
║      └─────────────────────────────────────────┘ ║
║                                                  ║
║  Stack cleanup order: callback → file2 → file1  ║
╚══════════════════════════════════════════════════╝
```

### `contextlib.nullcontext()`

A no-op context manager for conditional context management:

```python
from contextlib import nullcontext

def process_data(data, use_lock=False):
    """Conditionally use a lock"""
    import threading
    
    lock = threading.Lock() if use_lock else nullcontext()
    
    with lock:
        # Process data (with or without locking)
        print(f"Processing {len(data)} items")
        return [item.upper() for item in data]

# Usage
result1 = process_data(['a', 'b', 'c'], use_lock=True)   # With lock
result2 = process_data(['x', 'y', 'z'], use_lock=False)  # Without lock
```

---

## Advanced Context Management

### Nested Context Managers

You can nest multiple context managers:

```python
# Multiple context managers in one statement
with open('input.txt', 'r') as infile, open('output.txt', 'w') as outfile:
    content = infile.read()
    outfile.write(content.upper())

# Nested with statements
with tempfile.TemporaryDirectory() as temp_dir:
    temp_file = os.path.join(temp_dir, 'data.txt')
    
    with open(temp_file, 'w') as file:
        file.write("Nested context managers!")
        
        with timer():
            # Triple nesting!
            time.sleep(0.5)
```

### Context Manager as Decorator

Context managers can also be used as decorators:

```python
from contextlib import ContextDecorator

class benchmark(ContextDecorator):
    """Benchmark function execution time"""
    
    def __enter__(self):
        import time
        self.start_time = time.time()
        print("🏁 Benchmark started")
        return self
    
    def __exit__(self, exc_type, exc_value, traceback):
        import time
        end_time = time.time()
        elapsed = end_time - self.start_time
        print(f"⏱️  Execution time: {elapsed:.4f} seconds")
        return False

# Use as context manager
with benchmark():
    time.sleep(1)

# Use as decorator
@benchmark()
def slow_function():
    time.sleep(0.5)
    return "Done!"

result = slow_function()
```

### Reusable Context Managers

Some context managers can be reused, others cannot:

```python
# Reusable context manager
lock = threading.Lock()

with lock:
    print("First use")

with lock:
    print("Second use - OK!")

# Single-use context manager
@contextmanager
def single_use():
    print("Setup")
    yield
    print("Cleanup")

cm = single_use()
with cm:
    print("First use")

# This will raise RuntimeError: generator didn't yield
# with cm:
#     print("Second use - ERROR!")
```

---

## Asynchronous Context Managers

For asynchronous programming, Python provides async context managers:

### `async with` Statement

```python
import asyncio
from contextlib import asynccontextmanager

@asynccontextmanager
async def async_database_connection():
    """Async database connection context manager"""
    print("🔌 Connecting to async database...")
    # Simulate async connection
    await asyncio.sleep(0.1)
    connection = "Async DB Connection"
    
    try:
        yield connection
    finally:
        print("🔐 Closing async database connection...")
        await asyncio.sleep(0.1)

async def main():
    async with async_database_connection() as conn:
        print(f"Using {conn}")
        await asyncio.sleep(0.2)  # Simulate async work

# Run the async function
# asyncio.run(main())
```

### `contextlib.aclosing()`

For async resources that need closing:

```python
from contextlib import aclosing

async def async_generator():
    """Async generator that needs cleanup"""
    try:
        for i in range(5):
            yield f"Item {i}"
            await asyncio.sleep(0.1)
    finally:
        print("🧹 Async generator cleaned up")

async def process_async_data():
    async with aclosing(async_generator()) as agen:
        async for item in agen:
            print(f"📦 Received: {item}")
            if item == "Item 2":
                break  # Early exit triggers cleanup

# asyncio.run(process_async_data())
```

```ascii
╔════════════════════════════════════════════════════╗
║              Async Context Managers                ║
╠════════════════════════════════════════════════════╣
║                                                    ║
║  async with async_context_manager() as resource:   ║
║      ┌─────────────────────────────────────────┐   ║
║      │ await __aenter__()  # Setup             │   ║
║      │ resource = returned_value               │   ║
║      └─────────────────────────────────────────┘   ║
║                                                    ║
║      ┌─────────────────────────────────────────┐   ║
║      │ # Async operations with resource        │   ║
║      │ await some_async_operation(resource)    │   ║
║      └─────────────────────────────────────────┘   ║
║                                                    ║
║      ┌─────────────────────────────────────────┐   ║
║      │ await __aexit__()  # Cleanup            │   ║
║      │ # Always called, even on exceptions     │   ║
║      └─────────────────────────────────────────┘   ║
╚════════════════════════════════════════════════════╝
```

---

## Best Practices and Patterns

### 1. Always Use Context Managers for Resources

```python
# ❌ DON'T do this
file = open('data.txt', 'r')
data = file.read()
file.close()  # Might be forgotten or not reached

# ✅ DO this
with open('data.txt', 'r') as file:
    data = file.read()
# File automatically closed
```

### 2. Handle Exceptions Properly

```python
@contextmanager
def robust_context():
    """Context manager with proper exception handling"""
    resource = acquire_resource()
    try:
        yield resource
    except SpecificError as e:
        # Handle specific errors
        log_error(e)
        # Return True to suppress, False to propagate
        return False
    except Exception as e:
        # Handle unexpected errors
        log_critical_error(e)
        raise  # Always re-raise unexpected errors
    finally:
        # Cleanup always happens
        release_resource(resource)
```

### 3. Use `ExitStack` for Dynamic Resource Management

```python
def process_variable_files(filenames):
    """Handle variable number of files efficiently"""
    with ExitStack() as stack:
        files = []
        for filename in filenames:
            try:
                file = stack.enter_context(open(filename, 'r'))
                files.append(file)
            except FileNotFoundError:
                print(f"⚠️  Skipping missing file: {filename}")
                continue
        
        # Process all successfully opened files
        for file in files:
            process_file(file)
```

### 4. Make Context Managers Descriptive

```python
@contextmanager
def timed_operation(operation_name):
    """Timer with descriptive operation name"""
    start_time = time.time()
    print(f"🚀 Starting {operation_name}")
    
    try:
        yield
    finally:
        elapsed = time.time() - start_time
        print(f"✅ {operation_name} completed in {elapsed:.2f}s")

# Usage is self-documenting
with timed_operation("Database migration"):
    migrate_database()

with timed_operation("File processing"):
    process_large_file()
```

---

## Real-World Examples

### 1. Configuration Manager

```python
@contextmanager
def config_override(**overrides):
    """Temporarily override configuration values"""
    original_values = {}
    
    # Save original values and apply overrides
    for key, value in overrides.items():
        if hasattr(config, key):
            original_values[key] = getattr(config, key)
        setattr(config, key, value)
    
    try:
        yield config
    finally:
        # Restore original values
        for key, value in original_values.items():
            setattr(config, key, value)
        
        # Remove new keys that didn't exist before
        for key in overrides:
            if key not in original_values:
                delattr(config, key)

# Usage
with config_override(debug=True, log_level='DEBUG'):
    run_debug_operations()
# Configuration automatically restored
```

### 2. Performance Monitor

```python
@contextmanager
def performance_monitor(threshold_seconds=1.0):
    """Monitor performance and warn if threshold exceeded"""
    import psutil
    import time
    
    process = psutil.Process()
    start_time = time.time()
    start_memory = process.memory_info().rss
    start_cpu = process.cpu_percent()
    
    try:
        yield
    finally:
        end_time = time.time()
        end_memory = process.memory_info().rss
        end_cpu = process.cpu_percent()
        
        elapsed = end_time - start_time
        memory_diff = (end_memory - start_memory) / 1024 / 1024  # MB
        
        print(f"📊 Performance Report:")
        print(f"   ⏱️  Time: {elapsed:.3f}s")
        print(f"   🧠 Memory: {memory_diff:+.2f} MB")
        print(f"   🖥️  CPU: {end_cpu:.1f}%")
        
        if elapsed > threshold_seconds:
            print(f"⚠️  WARNING: Operation exceeded {threshold_seconds}s threshold!")

# Usage
with performance_monitor(threshold_seconds=0.5):
    # Your code here
    expensive_operation()
```

### 3. API Rate Limiter

```python
import time
from collections import defaultdict

class RateLimiter:
    def __init__(self):
        self.requests = defaultdict(list)
    
    @contextmanager
    def limit(self, key, max_requests, window_seconds):
        """Rate limiting context manager"""
        now = time.time()
        
        # Clean old requests
        self.requests[key] = [
            req_time for req_time in self.requests[key]
            if now - req_time < window_seconds
        ]
        
        # Check if we can make a request
        if len(self.requests[key]) >= max_requests:
            wait_time = window_seconds - (now - self.requests[key][0])
            print(f"🛑 Rate limit exceeded. Waiting {wait_time:.1f}s...")
            time.sleep(wait_time)
        
        # Record this request
        self.requests[key].append(now)
        
        try:
            yield
        except Exception as e:
            # Remove the request on failure
            if self.requests[key]:
                self.requests[key].pop()
            raise

# Usage
limiter = RateLimiter()

def api_call(user_id, data):
    with limiter.limit(f"user:{user_id}", max_requests=5, window_seconds=60):
        # Make API call
        print(f"🌐 Making API call for user {user_id}")
        return f"Response for {data}"
```

---

## Common Pitfalls and Solutions

### 1. Forgetting to Handle Exceptions in `__exit__`

```python
# ❌ WRONG - exceptions in __exit__ can mask original exceptions
class BadContextManager:
    def __exit__(self, exc_type, exc_value, traceback):
        risky_cleanup()  # If this raises, original exception is lost!

# ✅ CORRECT - protect cleanup operations
class GoodContextManager:
    def __exit__(self, exc_type, exc_value, traceback):
        try:
            risky_cleanup()
        except Exception as cleanup_error:
            if exc_type is None:
                # No original exception, re-raise cleanup error
                raise cleanup_error
            else:
                # Original exception takes precedence
                print(f"Cleanup error ignored: {cleanup_error}")
        return False  # Don't suppress original exception
```

### 2. Not Making Context Managers Reentrant When Needed

```python
import threading

class ReentrantContextManager:
    def __init__(self):
        self.lock = threading.RLock()  # Reentrant lock
        self.count = 0
    
    def __enter__(self):
        self.lock.acquire()
        self.count += 1
        print(f"🔒 Lock acquired (depth: {self.count})")
        return self
    
    def __exit__(self, exc_type, exc_value, traceback):
        self.count -= 1
        print(f"🔓 Lock released (depth: {self.count})")
        self.lock.release()
        return False

# Can be used in nested calls
manager = ReentrantContextManager()

def nested_function():
    with manager:
        print("Inner function")

def outer_function():
    with manager:
        print("Outer function")
        nested_function()  # This works because it's reentrant

outer_function()
```

### 3. Resource Leaks in Generators

```python
# ❌ POTENTIAL PROBLEM - generator not fully consumed
@contextmanager
def resource_manager():
    resource = acquire_expensive_resource()
    try:
        yield resource
    finally:
        release_expensive_resource(resource)

def problematic_usage():
    with resource_manager() as resource:
        for item in some_generator():
            if condition_met(item):
                return item  # Early return - cleanup still happens!
        # This is fine - context manager handles cleanup

# ✅ SOLUTION - context managers handle early exits correctly
def safe_usage():
    with resource_manager() as resource:
        # Even with early returns, exceptions, or breaks,
        # the finally block in the context manager runs
        return process_with_resource(resource)
```

---

## Performance Considerations

### Context Manager Overhead

Context managers have minimal overhead, but here are some considerations:

```python
import time

# Measuring context manager overhead
def measure_overhead():
    # Without context manager
    start = time.perf_counter()
    for _ in range(100000):
        file = open('/dev/null', 'w')
        file.close()
    no_context_time = time.perf_counter() - start
    
    # With context manager
    start = time.perf_counter()
    for _ in range(100000):
        with open('/dev/null', 'w') as file:
            pass
    context_time = time.perf_counter() - start
    
    print(f"Without context manager: {no_context_time:.4f}s")
    print(f"With context manager: {context_time:.4f}s")
    print(f"Overhead: {((context_time - no_context_time) / no_context_time) * 100:.2f}%")

# The overhead is typically negligible (< 5%)
```

### Optimizing Custom Context Managers

```python
# ✅ Efficient context manager
@contextmanager
def efficient_manager():
    # Minimize work in setup
    resource = quick_acquire()
    
    try:
        yield resource
    finally:
        # Defer expensive cleanup if possible
        schedule_cleanup(resource)  # Non-blocking

# ❌ Inefficient context manager
@contextmanager
def inefficient_manager():
    # Expensive setup
    resource = expensive_acquire()
    
    try:
        yield resource
    finally:
        # Blocking cleanup
        expensive_cleanup(resource)  # Blocks until complete
```

---

## Interactive Examples and Exercises

### Exercise 1: Create a Logging Context Manager

```python
@contextmanager
def log_activity(activity_name, log_level="INFO"):
    """Log the start and end of an activity"""
    import logging
    
    # TODO: Implement this context manager
    # - Log start of activity
    # - Handle exceptions and log them
    # - Log end of activity with duration
    pass

# Test your implementation
with log_activity("Database backup", "DEBUG"):
    time.sleep(1)  # Simulate work
    print("Backup completed!")
```

**Solution:**
```python
@contextmanager
def log_activity(activity_name, log_level="INFO"):
    import logging
    import time
    
    logger = logging.getLogger(__name__)
    start_time = time.time()
    
    logger.log(getattr(logging, log_level), f"🚀 Starting: {activity_name}")
    
    try:
        yield
    except Exception as e:
        logger.error(f"❌ Failed: {activity_name} - {e}")
        raise
    else:
        duration = time.time() - start_time
        logger.log(getattr(logging, log_level), 
                  f"✅ Completed: {activity_name} ({duration:.2f}s)")
```

### Exercise 2: File Backup Context Manager

```python
@contextmanager
def backup_on_write(filename):
    """Create a backup before writing to a file"""
    # TODO: Implement backup functionality
    # - Create backup of existing file (if it exists)
    # - Yield file handle for writing
    # - Handle errors (restore backup if write fails)
    pass

# Test your implementation
with backup_on_write("important_data.txt") as file:
    file.write("New important data!")
```

---

## Summary and Key Takeaways

```ascii
╔══════════════════════════════════════════════════════╗
║              Context Manager Mastery                ║
╠══════════════════════════════════════════════════════╣
║                                                      ║
║  🎯 Key Benefits:                                    ║
║     • Automatic resource management                  ║
║     • Exception safety                               ║
║     • Cleaner, more readable code                    ║
║     • Reduced boilerplate                            ║
║                                                      ║
║  🛠️  Implementation Methods:                         ║
║     • Class-based (__enter__, __exit__)              ║
║     • Generator-based (@contextmanager)              ║
║     • Built-in utilities (contextlib)                ║
║                                                      ║
║  🚀 Advanced Features:                               ║
║     • ExitStack for dynamic management               ║
║     • Async context managers                         ║
║     • Context managers as decorators                 ║
║                                                      ║
║  💡 Best Practices:                                  ║
║     • Always handle exceptions properly              ║
║     • Make cleanup operations safe                   ║
║     • Use descriptive names                          ║
║     • Consider reusability and reentrancy            ║
╚══════════════════════════════════════════════════════╝
```

### When to Use Context Managers

- **File operations**: Always use `with open()`
- **Resource management**: Database connections, network sockets
- **Lock management**: Thread synchronization
- **Temporary changes**: Configuration overrides, directory changes
- **Exception handling**: Suppressing specific errors
- **Timing and monitoring**: Performance measurement
- **Cleanup operations**: Temporary files, cache clearing

### Common Patterns

1. **Resource Acquisition/Release**: Files, connections, locks
2. **State Save/Restore**: Configuration, environment variables
3. **Setup/Teardown**: Test fixtures, temporary resources
4. **Enter/Exit Logging**: Activity tracking, debugging
5. **Exception Management**: Error suppression, custom handling

---

## Conclusion

Context managers are a fundamental feature of Python that promote clean, safe, and maintainable code. They embody Python's philosophy of making common patterns easy to implement and hard to get wrong.

Key takeaways:
- Use context managers for any resource that needs cleanup
- Prefer `@contextmanager` for simple cases, classes for complex ones
- Always handle exceptions properly in `__exit__` methods
- Leverage `contextlib` utilities for common patterns
- Consider using `ExitStack` for dynamic resource management

```ascii
🎉 Congratulations! You've mastered Python Context Managers! 🎉

┌─────────────────────────────────────────────────────┐
│  "With great power comes great responsibility"       │
│  - Use context managers wisely and your code        │
│    will be more robust, readable, and maintainable! │
└─────────────────────────────────────────────────────┘

Next steps:
• Practice implementing custom context managers
• Explore async context managers for asyncio code
• Check out contextlib source code for inspiration
• Use context managers in your next Python project!
```

---

*Happy coding with Python Context Managers! 🐍✨*

---

## Additional Resources

- [Official Python Documentation - contextlib](https://docs.python.org/3/library/contextlib.html)
- [PEP 343 - The "with" Statement](https://www.python.org/dev/peps/pep-0343/)
- [Real Python - Context Managers Guide](https://realpython.com/python-with-statement/)
- [Python Context Managers Best Practices](https://docs.python-guide.org/writing/structure/#context-managers)

---

**Created with ❤️ for Python developers who want to write better, safer code!**