# 🐍 Python Programming Paradigms: A Complete Interactive Guide

```
    ____        __  __                 ____                      ___                    
   / __ \__  __/ /_/ /_  ____  ____   / __ \____ __________ _____/ (_)___ _____ ___  _____
  / /_/ / / / / __/ __ \/ __ \/ __ \ / /_/ / __ `/ ___/ __ `/ __  / / __ `/ __ `__ \/ ___/
 / ____/ /_/ / /_/ / / / /_/ / / / // ____/ /_/ / /  / /_/ / /_/ / / /_/ / / / / / (__  ) 
/_/    \__, /\__/_/ /_/\____/_/ /_//_/    \__,_/_/   \__,_/\__,_/_/\__, /_/ /_/ /_/____/  
      /____/                                                      /____/                 
```

> *"Python lets more advanced developers use the style they feel is best suited to solve a particular problem."* - Jigyasa Grover

## 📋 Table of Contents

1. [Introduction to Programming Paradigms](#introduction-to-programming-paradigms)
2. [The Four Pillars of Python Paradigms](#the-four-pillars-of-python-paradigms)
3. [Imperative Programming](#imperative-programming)
4. [Functional Programming](#functional-programming)
5. [Procedural Programming](#procedural-programming) 
6. [Object-Oriented Programming](#object-oriented-programming)
7. [Advanced Functional Concepts](#advanced-functional-concepts)
8. [Paradigm Selection Guide](#paradigm-selection-guide)
9. [Real-World Applications](#real-world-applications)
10. [Practice Exercises](#practice-exercises)

---

## 🎯 Introduction to Programming Paradigms

A **programming paradigm** is a fundamental style or approach to writing code that provides a set of principles, concepts, and methodologies for designing and structuring programs. Think of paradigms as different "languages" or "dialects" for expressing solutions to computational problems.

```
┌─────────────────────────────────────────────────────────┐
│                Programming Paradigms                   │
├─────────────────────────────────────────────────────────┤
│  🎯 Define HOW we approach problem-solving             │
│  🏗️  Structure code organization and flow              │
│  🔧 Provide methodologies for implementation           │
│  🎨 Influence coding style and thinking patterns       │
└─────────────────────────────────────────────────────────┘
```

### Why Does Python Support Multiple Paradigms?

Python's philosophy of **"There should be one obvious way to do it"** might seem contradictory to supporting multiple paradigms, but in reality, different problems require different approaches:

- **Simple scripts** → Imperative/Procedural
- **Mathematical computations** → Functional  
- **Complex systems** → Object-Oriented
- **Data transformations** → Functional
- **Sequential processing** → Imperative

---

## 🏛️ The Four Pillars of Python Paradigms

```
       🏛️ PYTHON'S FOUR PARADIGMS 🏛️
    ┌──────────────────────────────────────┐
    │                                      │
    │  ⚡ IMPERATIVE    🔄 FUNCTIONAL       │
    │  Step-by-step    Mathematical        │
    │  Commands        Functions           │
    │                                      │
    │  📝 PROCEDURAL   🎭 OBJECT-ORIENTED  │
    │  Organized       Classes &           │
    │  Functions       Objects             │
    │                                      │
    └──────────────────────────────────────┘
```

### Quick Comparison Table

| Paradigm | Focus | Data Handling | Control Flow | Best For |
|----------|-------|---------------|--------------|----------|
| **Imperative** | How to solve | Mutable state | Sequential commands | Data manipulation |
| **Functional** | What to solve | Immutable | Function composition | Mathematical operations |
| **Procedural** | Organized procedures | Mutable state | Function calls | Modular programs |
| **Object-Oriented** | Real-world modeling | Encapsulated | Method calls | Complex systems |

---

## ⚡ Imperative Programming

> **"Tell the computer HOW to do something, step by step"**

### Core Characteristics

```
┌─────────────────────────────────────────┐
│         IMPERATIVE PARADIGM             │
├─────────────────────────────────────────┤
│ ✅ Sequential execution                 │
│ ✅ Mutable state changes                │
│ ✅ Explicit control flow                │
│ ✅ Direct memory manipulation           │
│ ✅ Command-based instructions           │
└─────────────────────────────────────────┘
```

### Visual Example: String Building

```python
# 🎯 IMPERATIVE APPROACH
# Building a string character by character

sample_characters = ['p', 'y', 't', 'h', 'o', 'n']
sample_string = ''

print("Step-by-step string building:")
print(f"Initial state: '{sample_string}'")

# Manual step-by-step approach
sample_string = sample_string + sample_characters[0]  # 'p'
print(f"After step 1: '{sample_string}'")

sample_string = sample_string + sample_characters[1]  # 'py'
print(f"After step 2: '{sample_string}'")

sample_string = sample_string + sample_characters[2]  # 'pyt'
print(f"After step 3: '{sample_string}'")

# More efficient imperative approach with loop
sample_string = ''
for i, char in enumerate(sample_characters):
    sample_string = sample_string + char
    print(f"Step {i+1}: '{sample_string}'")

print(f"Final result: '{sample_string}'")
```

### ASCII Flow Diagram

```
IMPERATIVE FLOW:
┌─────────┐    ┌─────────┐    ┌─────────┐    ┌─────────┐
│ Start   │───▶│ Command │───▶│ State   │───▶│ Next    │
│ State   │    │ Execute │    │ Update  │    │ Command │
└─────────┘    └─────────┘    └─────────┘    └─────────┘
     ▲                                            │
     └────────────────────────────────────────────┘
```

### Real-World Applications

```python
# 🔧 PRACTICAL EXAMPLE: File Processing
def process_log_file_imperative(filename):
    """Imperative approach to processing log files"""
    
    # Step 1: Initialize variables
    error_count = 0
    warning_count = 0
    processed_lines = []
    
    # Step 2: Open and read file
    with open(filename, 'r') as file:
        lines = file.readlines()
    
    # Step 3: Process each line sequentially
    for line_num, line in enumerate(lines, 1):
        line = line.strip()
        
        # Step 4: Check conditions and update state
        if 'ERROR' in line:
            error_count += 1
            processed_lines.append(f"Line {line_num}: {line}")
        elif 'WARNING' in line:
            warning_count += 1
            processed_lines.append(f"Line {line_num}: {line}")
    
    # Step 5: Return results
    return {
        'errors': error_count,
        'warnings': warning_count,
        'processed': processed_lines
    }
```

### Pros and Cons

```
✅ ADVANTAGES:
├── Easy to understand and debug
├── Direct control over execution
├── Efficient for sequential operations
├── Natural for beginners
└── Good performance for simple tasks

❌ DISADVANTAGES:
├── Hard to parallelize
├── Complex state management
├── Difficult to maintain large codebases
├── Side effects can cause bugs
└── Not suitable for concurrent execution
```

---

## 🔄 Functional Programming

> **"Tell the computer WHAT you want, not HOW to get it"**

### Core Characteristics

```
┌─────────────────────────────────────────┐
│         FUNCTIONAL PARADIGM             │
├─────────────────────────────────────────┤
│ ✅ Pure functions (no side effects)     │
│ ✅ Immutable data structures            │
│ ✅ Function composition                 │
│ ✅ Higher-order functions               │
│ ✅ Declarative style                    │
└─────────────────────────────────────────┘
```

### Lambda Functions: The Building Blocks

```python
# 🔥 LAMBDA FUNCTION EXAMPLES

# Basic lambda
square = lambda x: x ** 2
print(f"Square of 5: {square(5)}")  # Output: 25

# Lambda with conditions
check_even = lambda x: "Even" if x % 2 == 0 else "Odd"
print(f"8 is {check_even(8)}")  # Output: Even

# Lambda with multiple parameters
multiply = lambda x, y: x * y
print(f"3 × 4 = {multiply(3, 4)}")  # Output: 12

# Lambda returning multiple values
calc = lambda x, y: (x + y, x - y, x * y, x / y)
results = calc(10, 3)
print(f"Operations on 10 and 3: {results}")  # (13, 7, 30, 3.33...)
```

### The Holy Trinity: Map, Filter, Reduce

```
    🔄 FUNCTIONAL TRINITY 🔄
┌────────────────────────────────┐
│                                │
│  MAP     │  FILTER  │  REDUCE │
│  🔄      │  🔍      │  📉     │
│  Trans-  │  Select  │  Combine│
│  form    │  Items   │  All    │
│                                │
└────────────────────────────────┘
```

#### MAP: Transform Every Element

```python
# 🔄 MAP EXAMPLES

# Basic transformation
numbers = [1, 2, 3, 4, 5]
squares = list(map(lambda x: x**2, numbers))
print(f"Squares: {squares}")  # [1, 4, 9, 16, 25]

# String manipulation
words = ['python', 'java', 'javascript', 'go']
uppercase = list(map(str.upper, words))
print(f"Uppercase: {uppercase}")  # ['PYTHON', 'JAVA', 'JAVASCRIPT', 'GO']

# Multiple iterables
nums1 = [1, 2, 3]
nums2 = [4, 5, 6]
products = list(map(lambda x, y: x * y, nums1, nums2))
print(f"Products: {products}")  # [4, 10, 18]

# Real-world example: Temperature conversion
celsius_temps = [0, 20, 30, 40]
fahrenheit = list(map(lambda c: (c * 9/5) + 32, celsius_temps))
print(f"Fahrenheit: {fahrenheit}")  # [32.0, 68.0, 86.0, 104.0]
```

#### FILTER: Select Elements

```python
# 🔍 FILTER EXAMPLES

# Filter even numbers
numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
evens = list(filter(lambda x: x % 2 == 0, numbers))
print(f"Even numbers: {evens}")  # [2, 4, 6, 8, 10]

# Filter by string length
words = ['a', 'hello', 'python', 'ai', 'programming']
long_words = list(filter(lambda word: len(word) > 4, words))
print(f"Long words: {long_words}")  # ['hello', 'python', 'programming']

# Filter dictionaries
students = [
    {'name': 'Alice', 'grade': 85},
    {'name': 'Bob', 'grade': 92},
    {'name': 'Charlie', 'grade': 78},
    {'name': 'Diana', 'grade': 96}
]
honor_students = list(filter(lambda s: s['grade'] >= 90, students))
print(f"Honor students: {honor_students}")
```

#### REDUCE: Combine All Elements

```python
# 📉 REDUCE EXAMPLES
from functools import reduce

# Sum all numbers
numbers = [1, 2, 3, 4, 5]
total = reduce(lambda x, y: x + y, numbers)
print(f"Sum: {total}")  # 15

# Find maximum
maximum = reduce(lambda x, y: x if x > y else y, numbers)
print(f"Maximum: {maximum}")  # 5

# String concatenation
words = ['Python', 'is', 'awesome']
sentence = reduce(lambda x, y: x + ' ' + y, words)
print(f"Sentence: {sentence}")  # Python is awesome

# Complex example: Factorial
factorial_5 = reduce(lambda x, y: x * y, range(1, 6))
print(f"5! = {factorial_5}")  # 120
```

### Function Composition Example

```python
# 🔗 FUNCTION COMPOSITION
from functools import reduce

def compose(*functions):
    """Compose multiple functions into one"""
    return reduce(lambda f, g: lambda x: f(g(x)), functions, lambda x: x)

# Individual functions
add_ten = lambda x: x + 10
multiply_by_two = lambda x: x * 2
square = lambda x: x ** 2

# Compose them
combined = compose(square, multiply_by_two, add_ten)
result = combined(5)  # ((5 + 10) * 2) ** 2 = 30 ** 2 = 900
print(f"Result: {result}")
```

### ASCII Functional Flow

```
FUNCTIONAL FLOW:
┌─────────┐    ┌─────────┐    ┌─────────┐    ┌─────────┐
│ Input   │───▶│ Pure    │───▶│ Pure    │───▶│ Output  │
│ Data    │    │ Func 1  │    │ Func 2  │    │ Data    │
└─────────┘    └─────────┘    └─────────┘    └─────────┘
                    │              │
                    ▼              ▼
               No Side        No Side
               Effects        Effects
```

### Pros and Cons

```
✅ ADVANTAGES:
├── Easy to test and debug
├── Excellent for parallel processing
├── No side effects = fewer bugs
├── Highly reusable functions
├── Mathematical elegance
└── Great for data transformations

❌ DISADVANTAGES:
├── Can be memory intensive
├── Learning curve for beginners
├── Not always intuitive
├── Performance overhead
└── Limited for stateful operations
```

---

## 📝 Procedural Programming

> **"Organize code into reusable procedures and functions"**

### Core Characteristics

```
┌─────────────────────────────────────────┐
│        PROCEDURAL PARADIGM              │
├─────────────────────────────────────────┤
│ ✅ Function-based organization          │
│ ✅ Modular code structure               │
│ ✅ Top-down approach                    │
│ ✅ Shared global state                  │
│ ✅ Sequential execution                 │
└─────────────────────────────────────────┘
```

### Example: Calculator Program

```python
# 🧮 PROCEDURAL CALCULATOR

def add(a, b):
    """Add two numbers"""
    return a + b

def subtract(a, b):
    """Subtract two numbers"""
    return a - b

def multiply(a, b):
    """Multiply two numbers"""
    return a * b

def divide(a, b):
    """Divide two numbers with error handling"""
    if b == 0:
        return "Error: Division by zero!"
    return a / b

def display_menu():
    """Display calculator menu"""
    print("\n🧮 CALCULATOR MENU")
    print("1. Addition")
    print("2. Subtraction") 
    print("3. Multiplication")
    print("4. Division")
    print("5. Exit")

def get_numbers():
    """Get two numbers from user"""
    try:
        num1 = float(input("Enter first number: "))
        num2 = float(input("Enter second number: "))
        return num1, num2
    except ValueError:
        print("Invalid input! Please enter numbers.")
        return None, None

def calculator():
    """Main calculator function"""
    while True:
        display_menu()
        choice = input("Enter your choice (1-5): ")
        
        if choice == '5':
            print("Thanks for using the calculator!")
            break
        
        if choice in ['1', '2', '3', '4']:
            num1, num2 = get_numbers()
            if num1 is not None and num2 is not None:
                if choice == '1':
                    result = add(num1, num2)
                elif choice == '2':
                    result = subtract(num1, num2)
                elif choice == '3':
                    result = multiply(num1, num2)
                elif choice == '4':
                    result = divide(num1, num2)
                
                print(f"Result: {result}")
        else:
            print("Invalid choice! Please try again.")

# Run the calculator
if __name__ == "__main__":
    calculator()
```

### String Processing Example

```python
# 📝 PROCEDURAL STRING PROCESSING

def stringify(characters):
    """Convert list of characters to string"""
    result = ''
    for char in characters:
        result = result + char
    return result

def reverse_string(text):
    """Reverse a string"""
    return text[::-1]

def count_vowels(text):
    """Count vowels in text"""
    vowels = 'aeiouAEIOU'
    count = 0
    for char in text:
        if char in vowels:
            count += 1
    return count

def is_palindrome(text):
    """Check if text is palindrome"""
    cleaned = text.lower().replace(' ', '')
    return cleaned == cleaned[::-1]

def string_stats(text):
    """Get comprehensive string statistics"""
    stats = {
        'length': len(text),
        'words': len(text.split()),
        'vowels': count_vowels(text),
        'is_palindrome': is_palindrome(text),
        'reversed': reverse_string(text)
    }
    return stats

# Usage example
sample_chars = ['p', 'y', 't', 'h', 'o', 'n']
word = stringify(sample_chars)
print(f"Created word: {word}")
print(f"Statistics: {string_stats(word)}")
```

### ASCII Procedural Structure

```
PROCEDURAL STRUCTURE:
┌─────────────────────────────────────┐
│              MAIN PROGRAM           │
├─────────────────────────────────────┤
│  function_1()  │  function_2()     │
│       │        │       │           │
│       ▼        │       ▼           │
│  sub_func_a()  │  sub_func_b()     │
│       │        │       │           │
│       ▼        │       ▼           │
│   result_1     │   result_2        │
└─────────────────────────────────────┘
```

### Pros and Cons

```
✅ ADVANTAGES:
├── Easy to understand and maintain
├── Good code reusability
├── Natural problem decomposition
├── Easier debugging
├── Good for medium-sized programs
└── Clear program flow

❌ DISADVANTAGES:
├── Global state management issues
├── Naming conflicts possible
├── Limited data hiding
├── Harder to scale for large projects
├── Functions scattered across modules
└── Potential for duplicate logic
```

---

## 🎭 Object-Oriented Programming

> **"Model real-world entities as objects with data and behavior"**

### Core Characteristics

```
┌─────────────────────────────────────────┐
│      OBJECT-ORIENTED PARADIGM           │
├─────────────────────────────────────────┤
│ ✅ Encapsulation (data + methods)       │
│ ✅ Inheritance (code reuse)             │
│ ✅ Polymorphism (same interface)        │
│ ✅ Abstraction (hide complexity)        │
│ ✅ Classes and Objects                  │
└─────────────────────────────────────────┘
```

### String Operations Class Example

```python
# 🎭 OBJECT-ORIENTED STRING OPERATIONS

class StringProcessor:
    """A comprehensive string processing class"""
    
    def __init__(self, characters=None):
        """Initialize with optional character list"""
        self.characters = characters or []
        self.processed_strings = []
        self.operation_history = []
    
    def add_characters(self, chars):
        """Add characters to the processor"""
        self.characters.extend(chars)
        self.operation_history.append(f"Added {len(chars)} characters")
    
    def stringify(self):
        """Convert characters to string"""
        if not self.characters:
            return ""
        
        result = ''.join(self.characters)
        self.processed_strings.append(result)
        self.operation_history.append(f"Created string: '{result}'")
        return result
    
    def reverse_string(self, text=None):
        """Reverse a string or the current string"""
        if text is None:
            text = self.stringify()
        
        reversed_text = text[::-1]
        self.operation_history.append(f"Reversed: '{text}' -> '{reversed_text}'")
        return reversed_text
    
    def get_statistics(self):
        """Get processor statistics"""
        current_string = ''.join(self.characters)
        return {
            'character_count': len(self.characters),
            'current_string': current_string,
            'processed_count': len(self.processed_strings),
            'operations_performed': len(self.operation_history)
        }
    
    def show_history(self):
        """Display operation history"""
        print("📜 Operation History:")
        for i, operation in enumerate(self.operation_history, 1):
            print(f"  {i}. {operation}")
    
    def clear(self):
        """Clear all data"""
        self.characters.clear()
        self.processed_strings.clear()
        self.operation_history.append("Cleared all data")

# Advanced inheritance example
class AdvancedStringProcessor(StringProcessor):
    """Extended string processor with advanced features"""
    
    def __init__(self, characters=None):
        super().__init__(characters)
        self.encoding = 'utf-8'
        self.case_transformations = []
    
    def to_uppercase(self):
        """Convert string to uppercase"""
        text = self.stringify()
        upper_text = text.upper()
        self.case_transformations.append(('upper', text, upper_text))
        return upper_text
    
    def to_lowercase(self):
        """Convert string to lowercase"""
        text = self.stringify()
        lower_text = text.lower()
        self.case_transformations.append(('lower', text, lower_text))
        return lower_text
    
    def to_title_case(self):
        """Convert string to title case"""
        text = self.stringify()
        title_text = text.title()
        self.case_transformations.append(('title', text, title_text))
        return title_text
    
    def analyze_text(self):
        """Perform comprehensive text analysis"""
        text = self.stringify()
        return {
            'length': len(text),
            'words': len(text.split()),
            'characters': len([c for c in text if c.isalpha()]),
            'digits': len([c for c in text if c.isdigit()]),
            'spaces': len([c for c in text if c.isspace()]),
            'uppercase': len([c for c in text if c.isupper()]),
            'lowercase': len([c for c in text if c.islower()])
        }

# Usage examples
print("🎭 OBJECT-ORIENTED EXAMPLE")
print("=" * 40)

# Basic usage
processor = StringProcessor(['p', 'y', 't', 'h', 'o', 'n'])
result = processor.stringify()
print(f"Basic string: {result}")

# Advanced usage
advanced = AdvancedStringProcessor(['H', 'e', 'l', 'l', 'o', ' ', 'W', 'o', 'r', 'l', 'd'])
original = advanced.stringify()
print(f"\nOriginal: {original}")
print(f"Uppercase: {advanced.to_uppercase()}")
print(f"Lowercase: {advanced.to_lowercase()}")
print(f"Title case: {advanced.to_title_case()}")
print(f"Analysis: {advanced.analyze_text()}")

advanced.show_history()
```

### Polymorphism Example

```python
# 🔄 POLYMORPHISM EXAMPLE

class Shape:
    """Base shape class"""
    def area(self):
        raise NotImplementedError("Subclass must implement area method")
    
    def perimeter(self):
        raise NotImplementedError("Subclass must implement perimeter method")

class Rectangle(Shape):
    def __init__(self, width, height):
        self.width = width
        self.height = height
    
    def area(self):
        return self.width * self.height
    
    def perimeter(self):
        return 2 * (self.width + self.height)

class Circle(Shape):
    def __init__(self, radius):
        self.radius = radius
    
    def area(self):
        return 3.14159 * self.radius ** 2
    
    def perimeter(self):
        return 2 * 3.14159 * self.radius

class Triangle(Shape):
    def __init__(self, base, height, side1, side2, side3):
        self.base = base
        self.height = height
        self.sides = [side1, side2, side3]
    
    def area(self):
        return 0.5 * self.base * self.height
    
    def perimeter(self):
        return sum(self.sides)

# Polymorphic function
def print_shape_info(shape):
    """Print information about any shape"""
    print(f"{shape.__class__.__name__}:")
    print(f"  Area: {shape.area():.2f}")
    print(f"  Perimeter: {shape.perimeter():.2f}")

# Usage
shapes = [
    Rectangle(5, 3),
    Circle(4),
    Triangle(6, 4, 5, 5, 6)
]

for shape in shapes:
    print_shape_info(shape)
    print()
```

### ASCII OOP Structure

```
OBJECT-ORIENTED STRUCTURE:
┌─────────────────────────────────────┐
│              CLASS                  │
├─────────────────────────────────────┤
│  🏠 ATTRIBUTES (Data)               │
│  ├── private_var                    │
│  ├── public_var                     │
│  └── protected_var                  │
│                                     │
│  🔧 METHODS (Behavior)              │
│  ├── __init__()                     │
│  ├── public_method()                │
│  ├── _protected_method()            │
│  └── __private_method()             │
└─────────────────────────────────────┘
          │
          ▼
    ┌─────────┐
    │ OBJECT  │
    │ (Instance)
    └─────────┘
```

### Pros and Cons

```
✅ ADVANTAGES:
├── Excellent code organization
├── Data encapsulation and security
├── Code reusability through inheritance
├── Easy to maintain and extend
├── Models real-world entities well
├── Supports polymorphism
└── Great for large applications

❌ DISADVANTAGES:
├── Can be overly complex for simple tasks
├── Performance overhead
├── Steep learning curve
├── Can lead to over-engineering
├── Memory usage for objects
└── Inheritance hierarchies can become complex
```

---

## 🚀 Advanced Functional Concepts

### Higher-Order Functions

```python
# 🔝 HIGHER-ORDER FUNCTIONS

def create_multiplier(factor):
    """Returns a function that multiplies by factor"""
    return lambda x: x * factor

def apply_operation(operation, values):
    """Apply operation to all values"""
    return [operation(value) for value in values]

def compose_functions(*functions):
    """Compose multiple functions"""
    from functools import reduce
    return reduce(lambda f, g: lambda x: f(g(x)), functions)

# Usage examples
double = create_multiplier(2)
triple = create_multiplier(3)

numbers = [1, 2, 3, 4, 5]
doubled = apply_operation(double, numbers)
tripled = apply_operation(triple, numbers)

print(f"Original: {numbers}")
print(f"Doubled: {doubled}")
print(f"Tripled: {tripled}")

# Function composition
add_one = lambda x: x + 1
square = lambda x: x ** 2
add_ten = lambda x: x + 10

composed = compose_functions(add_ten, square, add_one)
result = composed(3)  # ((3 + 1) ** 2) + 10 = 26
print(f"Composed result: {result}")
```

### Decorators: Functional Programming's Swiss Army Knife

```python
# 🎯 DECORATORS EXAMPLE

import time
import functools

def timer(func):
    """Decorator to time function execution"""
    @functools.wraps(func)
    def wrapper(*args, **kwargs):
        start = time.time()
        result = func(*args, **kwargs)
        end = time.time()
        print(f"{func.__name__} took {end - start:.4f} seconds")
        return result
    return wrapper

def cache(func):
    """Simple memoization decorator"""
    cached_results = {}
    
    @functools.wraps(func)
    def wrapper(*args):
        if args in cached_results:
            print(f"Cache hit for {args}")
            return cached_results[args]
        
        result = func(*args)
        cached_results[args] = result
        print(f"Cache miss for {args}, computed result")
        return result
    
    return wrapper

def validate_positive(func):
    """Validate that all arguments are positive"""
    @functools.wraps(func)
    def wrapper(*args, **kwargs):
        for arg in args:
            if isinstance(arg, (int, float)) and arg < 0:
                raise ValueError(f"All arguments must be positive, got {arg}")
        return func(*args, **kwargs)
    return wrapper

# Usage with multiple decorators
@timer
@cache
@validate_positive
def fibonacci(n):
    """Calculate Fibonacci number"""
    if n <= 1:
        return n
    return fibonacci(n-1) + fibonacci(n-2)

# Test the decorated function
print("🔢 Fibonacci with decorators:")
print(f"fib(10) = {fibonacci(10)}")
print(f"fib(10) = {fibonacci(10)}")  # Should hit cache
```

### Closures and Lexical Scoping

```python
# 🔒 CLOSURES EXAMPLE

def create_account(initial_balance=0):
    """Create a bank account with closure"""
    balance = initial_balance
    transaction_history = []
    
    def deposit(amount):
        nonlocal balance
        if amount > 0:
            balance += amount
            transaction_history.append(f"Deposited: ${amount}")
            return balance
        raise ValueError("Deposit amount must be positive")
    
    def withdraw(amount):
        nonlocal balance
        if amount > balance:
            raise ValueError("Insufficient funds")
        if amount > 0:
            balance -= amount
            transaction_history.append(f"Withdrew: ${amount}")
            return balance
        raise ValueError("Withdrawal amount must be positive")
    
    def get_balance():
        return balance
    
    def get_history():
        return transaction_history.copy()
    
    def account_info():
        return {
            'balance': balance,
            'transactions': len(transaction_history),
            'history': transaction_history.copy()
        }
    
    # Return account interface
    return {
        'deposit': deposit,
        'withdraw': withdraw,
        'balance': get_balance,
        'history': get_history,
        'info': account_info
    }

# Usage
print("🏦 CLOSURE BANK ACCOUNT")
print("=" * 30)

account = create_account(100)
print(f"Initial balance: ${account['balance']()}")

account['deposit'](50)
print(f"After deposit: ${account['balance']()}")

account['withdraw'](30)
print(f"After withdrawal: ${account['balance']()}")

print(f"Account info: {account['info']()}")
```

---

## 🧭 Paradigm Selection Guide

### Decision Matrix

```
┌─────────────────────────────────────────────────────┐
│              PARADIGM SELECTION GUIDE               │
├─────────────────────────────────────────────────────┤
│                                                     │
│  Problem Type          │  Recommended Paradigm     │
│  ─────────────────────│───────────────────────── │
│  🔢 Mathematical       │  Functional               │
│  📊 Data Processing    │  Functional               │
│  🎮 Game Development   │  Object-Oriented          │
│  🌐 Web Applications   │  Object-Oriented          │
│  📜 Scripts & Tools    │  Procedural/Imperative    │
│  🤖 AI/ML Pipelines    │  Functional + OOP         │
│  📱 Mobile Apps        │  Object-Oriented          │
│  ⚡ System Programming │  Procedural/Imperative    │
│                                                     │
└─────────────────────────────────────────────────────┘
```

### When to Use Each Paradigm

#### Choose **Imperative** when:
- Building simple scripts
- Direct hardware interaction needed
- Performance is critical
- Sequential processing required
- Debugging step-by-step execution

#### Choose **Functional** when:
- Data transformations
- Mathematical computations
- Parallel processing needed
- Testing is crucial
- Avoiding side effects

#### Choose **Procedural** when:
- Medium-sized applications
- Clear problem decomposition
- Team collaboration
- Modular development
- Reusable components needed

#### Choose **Object-Oriented** when:
- Complex systems
- Real-world modeling
- Large teams
- Long-term maintenance
- GUI applications

---

## 🌍 Real-World Applications

### Machine Learning Pipeline

```python
# 🤖 ML PIPELINE COMBINING PARADIGMS

# Functional for data preprocessing
def clean_data(data):
    """Functional data cleaning"""
    return list(filter(lambda x: x is not None, data))

def normalize_data(data):
    """Functional normalization"""
    max_val = max(data)
    min_val = min(data)
    return list(map(lambda x: (x - min_val) / (max_val - min_val), data))

def transform_features(data, transformations):
    """Apply multiple transformations functionally"""
    from functools import reduce
    return reduce(lambda d, transform: transform(d), transformations, data)

# Object-oriented for model structure
class MLModel:
    """Object-oriented ML model"""
    
    def __init__(self, name):
        self.name = name
        self.trained = False
        self.parameters = {}
        self.training_history = []
    
    def preprocess(self, data):
        """Preprocessing pipeline"""
        transformations = [clean_data, normalize_data]
        return transform_features(data, transformations)
    
    def train(self, data, labels):
        """Train the model (simplified)"""
        processed_data = self.preprocess(data)
        # Simulated training
        self.parameters['weights'] = [0.5] * len(processed_data)
        self.trained = True
        self.training_history.append(f"Trained on {len(data)} samples")
        return self
    
    def predict(self, data):
        """Make predictions"""
        if not self.trained:
            raise ValueError("Model must be trained first")
        
        processed = self.preprocess(data)
        # Simulated prediction
        return [sum(x * w for x, w in zip([d], self.parameters['weights'])) 
                for d in processed]

# Procedural for workflow orchestration
def run_ml_pipeline():
    """Procedural pipeline orchestration"""
    print("🤖 Running ML Pipeline")
    
    # Generate sample data
    import random
    train_data = [random.random() * 100 for _ in range(50)]
    train_labels = [1 if x > 50 else 0 for x in train_data]
    test_data = [random.random() * 100 for _ in range(10)]
    
    # Create and train model
    model = MLModel("SampleModel")
    model.train(train_data, train_labels)
    
    # Make predictions
    predictions = model.predict(test_data)
    
    # Display results
    print(f"Model: {model.name}")
    print(f"Training History: {model.training_history}")
    print(f"Predictions: {predictions[:5]}...")  # Show first 5
    
    return model, predictions

# Run the pipeline
model, results = run_ml_pipeline()
```

### Web API with Mixed Paradigms

```python
# 🌐 WEB API EXAMPLE

# Functional utilities
def validate_email(email):
    """Functional email validation"""
    import re
    pattern = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$'
    return bool(re.match(pattern, email))

def sanitize_input(data):
    """Functional input sanitization"""
    if isinstance(data, str):
        return data.strip().lower()
    return data

def apply_filters(items, filters):
    """Functional filtering"""
    from functools import reduce
    return reduce(lambda data, f: list(filter(f, data)), filters, items)

# Object-oriented models
class User:
    """User model"""
    
    def __init__(self, username, email, age=None):
        self.username = sanitize_input(username)
        self.email = email
        self.age = age
        self.created_at = self._get_timestamp()
        
        if not validate_email(email):
            raise ValueError("Invalid email format")
    
    def _get_timestamp(self):
        """Private method for timestamp"""
        from datetime import datetime
        return datetime.now().isoformat()
    
    def to_dict(self):
        """Convert to dictionary"""
        return {
            'username': self.username,
            'email': self.email,
            'age': self.age,
            'created_at': self.created_at
        }
    
    def update_profile(self, **kwargs):
        """Update user profile"""
        for key, value in kwargs.items():
            if hasattr(self, key):
                setattr(self, key, value)

class UserRepository:
    """User repository for data management"""
    
    def __init__(self):
        self.users = []
        self.next_id = 1
    
    def create_user(self, username, email, age=None):
        """Create new user"""
        user = User(username, email, age)
        user.id = self.next_id
        self.next_id += 1
        self.users.append(user)
        return user
    
    def get_all_users(self):
        """Get all users"""
        return [user.to_dict() for user in self.users]
    
    def find_users_by_age(self, min_age=None, max_age=None):
        """Find users by age range using functional approach"""
        filters = []
        
        if min_age is not None:
            filters.append(lambda u: u.age and u.age >= min_age)
        if max_age is not None:
            filters.append(lambda u: u.age and u.age <= max_age)
        
        return apply_filters(self.users, filters)

# Procedural API handlers
def handle_create_user(repo, data):
    """Handle user creation request"""
    try:
        username = data.get('username')
        email = data.get('email')
        age = data.get('age')
        
        if not username or not email:
            return {'error': 'Username and email are required'}, 400
        
        user = repo.create_user(username, email, age)
        return {'user': user.to_dict(), 'message': 'User created successfully'}, 201
    
    except ValueError as e:
        return {'error': str(e)}, 400

def handle_get_users(repo, filters=None):
    """Handle get users request"""
    try:
        if filters:
            min_age = filters.get('min_age')
            max_age = filters.get('max_age')
            users = repo.find_users_by_age(min_age, max_age)
            return {'users': [u.to_dict() for u in users]}, 200
        else:
            users = repo.get_all_users()
            return {'users': users}, 200
    
    except Exception as e:
        return {'error': str(e)}, 500

# Usage example
print("🌐 WEB API SIMULATION")
print("=" * 30)

# Create repository
repo = UserRepository()

# Create users
user_data = [
    {'username': 'alice', 'email': 'alice@example.com', 'age': 25},
    {'username': 'bob', 'email': 'bob@example.com', 'age': 30},
    {'username': 'charlie', 'email': 'charlie@example.com', 'age': 35}
]

for data in user_data:
    response, status = handle_create_user(repo, data)
    print(f"Create user: {response}")

# Get all users
response, status = handle_get_users(repo)
print(f"\nAll users: {response}")

# Filter users
response, status = handle_get_users(repo, {'min_age': 30})
print(f"\nUsers 30+: {response}")
```

---

## 🏋️ Practice Exercises

### Exercise 1: String Manipulation Challenge

```python
# 🎯 EXERCISE 1: Implement the same functionality in all paradigms

sample_text = "Python Programming Paradigms"

# TODO: Implement these functions in each paradigm:
# 1. Count vowels
# 2. Reverse words
# 3. Convert to title case
# 4. Remove duplicates

# IMPERATIVE SOLUTION:
def imperative_solution(text):
    # Your implementation here
    pass

# FUNCTIONAL SOLUTION:
def functional_solution(text):
    # Your implementation here  
    pass

# PROCEDURAL SOLUTION:
def procedural_solution(text):
    # Your implementation here
    pass

# OBJECT-ORIENTED SOLUTION:
class TextProcessor:
    # Your implementation here
    pass
```

### Exercise 2: Data Processing Pipeline

```python
# 🎯 EXERCISE 2: Build a data processing pipeline

sales_data = [
    {'product': 'laptop', 'price': 999.99, 'quantity': 2, 'region': 'north'},
    {'product': 'mouse', 'price': 29.99, 'quantity': 5, 'region': 'south'},
    {'product': 'keyboard', 'price': 79.99, 'quantity': 3, 'region': 'north'},
    {'product': 'monitor', 'price': 299.99, 'quantity': 1, 'region': 'west'},
]

# TODO: Implement using different paradigms:
# 1. Calculate total revenue per region
# 2. Find top-selling product by quantity
# 3. Apply discount to expensive items (>$100)
# 4. Generate summary report
```

### Exercise 3: Game Development Challenge

```python
# 🎯 EXERCISE 3: Simple RPG Character System

# TODO: Design a character system that supports:
# 1. Different character classes (Warrior, Mage, Archer)
# 2. Level progression
# 3. Skill systems
# 4. Combat calculations
# 5. Equipment management

# Try implementing using:
# - Object-oriented approach
# - Functional approach with immutable data
# - Mixed paradigm approach
```

---

## 🎊 Conclusion

Python's multi-paradigm nature is one of its greatest strengths. Rather than forcing you into a single way of thinking, Python gives you the flexibility to choose the right tool for the job:

### Key Takeaways

```
🔑 PARADIGM SELECTION PRINCIPLES:
├── 🎯 Choose based on problem domain
├── 🔧 Consider team expertise
├── 📈 Think about scalability needs
├── 🧪 Evaluate testing requirements
├── ⚡ Balance performance needs
└── 🔄 Don't be afraid to mix paradigms
```

### The Paradigm Evolution

```
BEGINNER    ────▶    INTERMEDIATE    ────▶    ADVANCED
Imperative           Procedural +           All Paradigms
Only                 Basic OOP              + Mixed Approaches
```

### Remember: There's No "Perfect" Paradigm

The best programmers are those who understand when and how to apply different paradigms. Python's beauty lies in letting you express solutions in the most natural and efficient way for each specific problem.

> *"The amazing thing about Python is that it lets you choose the programming paradigm that works the best for you in a given situation."* - The Python Community

---

## 📚 Additional Resources

- **Books**: "Fluent Python" by Luciano Ramalho
- **Online**: Real Python, Python.org tutorials
- **Practice**: HackerRank, LeetCode functional programming sections
- **Communities**: r/Python, Python Discord servers

### Next Steps

1. **Practice** each paradigm with real projects
2. **Experiment** with mixing paradigms
3. **Read** other people's code to see different approaches
4. **Build** something complex using your preferred paradigm
5. **Teach** others what you've learned

---

*Happy Coding! 🐍✨*

```
        🎉 You've completed the Python Paradigms Guide! 🎉
    ┌─────────────────────────────────────────────────────┐
    │  Now go forth and code with paradigmatic wisdom!    │
    └─────────────────────────────────────────────────────┘
```